[{"title":"只出现一次的数字（水了个简单题）","url":"/2022/04/21/只出现一次的数字（水了个简单题）/","content":"\n\n\n# 题目\n\n题目：[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n>\n>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n<!-- more -->\n\n**示例 1:**\n\n```\n输入: [2,2,1]\n输出: 1\n```\n\n**示例 2:**\n\n```\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n\n题解：\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        //用异或 ，因为 a^b^a = b \n        int res = 0;\n        for (int num : nums) {\n            //所以\n            res ^= num;\n        }\n        return res;\n    }\n}\n```\n\n","tags":["每天进步一点点系列"]},{"title":"名侦探柯南核心人物图","url":"/2022/04/19/名侦探柯南核心人物图/","content":"\n # 核心人物图\n\n![柯南](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%9F%AF%E5%8D%97.webp)\n\n\n\n<!-- more -->\n\n\n\n![新一](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%96%B0%E4%B8%80.webp)\n\n\n\n![小兰](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E5%B0%8F%E5%85%B0.webp)\n\n\n\n![毛利小五郎](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%AF%9B%E5%88%A9%E5%B0%8F%E4%BA%94%E9%83%8E.webp)\n\n![阿笠博士](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191545827.webp)\n\n![妃英理](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546437.webp)\n\n![工藤优作](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546944.webp)\n\n![工藤有希子](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546523.webp)\n\n![目暮警官](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546974.webp)\n\n![高木](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546545.webp)\n\n![佐藤](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546185.webp)\n\n![光彦](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546688.webp)\n\n![元太](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546998.webp)\n\n![园子](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547553.webp)\n\n![步美](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547061.webp)\n\n![怪盗基德](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547557.webp)\n\n![和叶](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547245.webp)\n\n![平次](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547818.webp)\n\n\n\n\n\n来源\n\n百度百科：[柯南](https://baike.baidu.com/item/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/3469662?fromtitle=%E6%9F%AF%E5%8D%97&fromid=14081833)\n\n","tags":["柯南"]},{"title":"组合总和-Leetcode","url":"/2022/04/19/组合总和-Leetcode/","content":"\n# 每日题目\n\n题目：[组合总和](https://leetcode-cn.com/problems/combination-sum/)\n\n> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n>\n> candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n>\n> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n>\n\n<!-- more -->\n\n示例：\n\n> 示例 1：\n>\n> 输入：candidates = [2,3,6,7], target = 7\n> 输出：[[2,2,3],[7]]\n> 解释：\n> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n> 7 也是一个候选， 7 = 7 。\n> 仅有这两种组合。\n>\n> 示例 2：\n>\n> 输入: candidates = [2,3,5], target = 8\n> 输出: [[2,2,2,2],[2,3,3],[3,5]]\n>\n> 示例 3：\n>\n> 输入: candidates = [2], target = 1\n> 输出: []\n\n\n\n>\n> 提示：\n>\n> 1 <= candidates.length <= 30\n> 1 <= candidates[i] <= 200\n> candidate 中的每个元素都 互不相同\n> 1 <= target <= 500\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res =  new ArrayList<>();\n        //如果数组为空，直接返回空结果\n        if(candidates==null||candidates.length==0){\n            return res;\n        }\n        //先排序\n        Arrays.sort(candidates);\n        //dfs\n        dfs(candidates,target,0,new ArrayList<>(),res);\n        return res;\n    }\n\n    public void dfs(int[] candidates,int target ,int start,List<Integer> list,List<List<Integer>> res){\n        //如果目标值为0，说明已经找到一个组合，添加到结果集中\n        if(target==0){\n            res.add(new ArrayList<>(list));\n            return;\n        }\n        //遍历数组\n        for (int i = start; i < candidates.length; i++) {\n            //如果当前值大于目标值，则不需要继续遍历\n            if(candidates[i]>target){\n                return;\n            }\n            list.add(candidates[i]);\n            //更新目标值和起始位置\n            dfs(candidates,target-candidates[i],i,list,res);\n            //回溯,删除当前值\n            list.remove(list.size()-1);\n        }\n\n\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220419095327903](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220419095327903.png)","tags":["每天进步一点点系列"]},{"title":"计算器","url":"/2022/04/18/计算器/","content":"\n# 每日题目\n\n题目：[计算器](https://leetcode-cn.com/problems/calculator-lcci/)\n\n> 给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。\n>\n> 表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。\n>\n\n<!-- more -->\n\n示例：\n\n> 示例 1:\n>\n> 输入: \"3+2*2\"\n> 输出: 7\n>\n> 示例 2:\n>\n> 输入: \" 3/2 \"\n> 输出: 1\n>\n> 示例 3:\n>\n> 输入: \" 3+5 / 2 \"\n> 输出: 5\n>\n> 说明：\n>\n> 你可以假设所给定的表达式都是有效的。\n> 请不要使用内置的库函数 eval。\n\n\n\n> 小坑，字符串里有空格，需要替换掉\n\n\n\n代码：\n\n```java\nclass Solution {\n    public int calculate(String s) {\n        s =s.replaceAll(\" \",\"\");\n        Deque<Integer> stack = new ArrayDeque<>();\n        //先把第一个加进去\n        char flag = '+';\n        //数字的初始值\n        int num = 0;\n        for(int i=0;i<s.length();i++){\n            //转换成数字\n            if(Character.isDigit(s.charAt(i))){\n                num = num*10+s.charAt(i)-'0';\n            }\n            //根据符号进行运行，就是*和/，优先级高，先把栈中的数字拿出来，运算后放进去\n            if(!Character.isDigit(s.charAt(i)) || i==s.length()-1){\n                if(flag=='+'){\n                    stack.push(num);\n                }else if(flag=='-'){\n                    stack.push(-num);\n                }else if(flag=='*'){\n                    stack.push(stack.pop()*num);\n                }else if(flag=='/'){\n                    stack.push(stack.pop()/num);\n                }\n                flag = s.charAt(i);\n                num =0;\n            }\n\n        }\n        //遍历栈，累加结果\n        int res =0;\n        while(!stack.isEmpty()){\n            res += stack.pop();\n        }\n\n        return res;\n\n\n    }\n}\n```\n\n","tags":["每天进步一点点系列"]},{"title":"使用LamdbaUpdateWrapper的setSql作用及风险","url":"/2022/04/12/使用LamdbaUpdateWrapper的setSql作用及风险/","content":"\n\n\n# 问题引入\n\n\n\n> 先思考下：我们要对数据库里面的某条数据进行更新，并且想要在某个字段原先的基础上修改，我们怎么办？\n\n\n\n<!-- more -->\n\n\n\n>正常的情况下，我们需要先查出来再更新，可就是想直接更新，那就需要去Mapper中写sql，就为了一个字段感觉费劲，在这种情况下使用LamdbaUpdateWrapper的setSql()方法即可。\n\n\n\n```java\n//把num字段加5\nLambdaUpdateWrapper<User> updateWrapper = Wrappers.<User>lambdaUpdate()\n\t.eq(User::getId, userId)\n\t.setSql(\"count = count + 5\");\n\nuserService.update(updateWrapper);\n```\n\n\n\nBUT，这样就会存在可能有风险，主要还是为了测试mybatis-plus，是否进行的防范，经过测试，并没有。\n\n比如就使用最常见的 sleep()，把这部分加到sql段中 `+ sleep(5)`\n\n```java\nLambdaUpdateWrapper<User> updateWrapper = Wrappers.<User>lambdaUpdate()\n                .eq(User::getId, userId)\n                .setSql(\"count = count + 5 + sleep(5)\");\n```\n\n\n\n![image-20220418154212043](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220418154212043.png)\n\n\n\n不过话说回来，这也就是开发人员能接触到的，只是证明mybatis-plus并没有对setSql()进行过滤，是采取直接拼上去的方式。\n\n\n\n# 每日单词\n\n![image-20220418154234138](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220418154234138.png)","tags":["java"]},{"title":"最小差值（附加单词积累）","url":"/2022/04/12/最小差值（附加单词积累）/","content":"\n\n\n# 每日题目\n\n题目：[最小差值 I](https://leetcode-cn.com/problems/smallest-range-i/)\n\n> 给你一个整数数组 nums，和一个整数 k 。\n>\n> 在一个操作中，您可以选择 0 <= i < nums 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。\n>\n> nums 的 分数 是 nums 中最大和最小元素的差值。 \n>\n> 在对nums中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。\n\n<!-- more -->\n\n示例：\n\n> 示例 1：\n>\n> 输入：nums = [1], k = 0\n> 输出：0\n> 解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。\n> 示例 2：\n>\n> 输入：nums = [0,10], k = 2\n> 输出：6\n> 解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n> 示例 3：\n>\n> 输入：nums = [1,3,6], k = 3\n> 输出：0\n> 解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n\n\n提示：\n\n> 1 <= nums.length <= 104\n> 0 <= nums[i] <= 104\n> 0 <= k <= 104\n\n代码：\n\n```java\nclass Solution {\n    public int smallestRangeI(int[] nums, int k) {\n        int res =0;\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        //取最大最小值\n        for (int num : nums) {\n            max = Math.max(max, num);\n            min = Math.min(min, num);\n        }\n        //这样取最大最小值速度慢\n//        Arrays.sort(nums);\n//        min = nums[0];\n//        max = nums[nums.length - 1];\n        //最大值减k，最小值加k，然后算差值res\n        res = max - min - 2 * k;\n        //因为k可变，如果res<0,就证明可以把最大最小值变成一样，so，res = 0\n        if(res < 0) {\n            res = 0;\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220412120606361](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220412120606361.png)","tags":["每天进步一点点系列"]},{"title":"DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】","url":"/2022/03/18/DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】/","content":"\n\n\n# DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】\n\n\n\n# 第一步：下载DataGrip\n\n**官网地址：[戳这里](https://www.jetbrains.com/zh-cn/datagrip/download/#section=windows)**\n\n![image-20210913111047913](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021459816.png)\n\n\n\n<!-- more -->\n\n\n\n# 第二步：添加人大金仓的数据库引擎\n\n> **其实就是选择我们本地仓库引入的jar包**\n\n\n\n**如下图：**\n\n![image-20210913111417486](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021459327.png)\n\n> **选择Driver Files，也就是我们本地仓库中kingbase8的jar包**\n\n\n\n![image-20210913111636394](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500539.png)\n\n> **从本地仓库中找到**\n\n\n\n![image-20210913111654473](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500709.png)\n\n\n\n> **切换Class**\n\n\n\n![image-20210913111758561](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500688.png)\n\n> **完成后如下图：**\n\n\n\n![image-20210913111507062](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500158.png)\n\n\n\n> **点击Apply保存引擎**\n\n\n\n![image-20210913111854079](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500077.png)\n\n# 第三步：输入账号密码连接\n\n![image-20210913112022474](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500183.png)\n\n\n\n> **先测试连接一下**\n\n![image-20210913112050134](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500322.png)\n\n> **没有问题就点击OK**\n\n\n\n# 第四步：查看数据库\n\n\n\n> **我们需要勾选下All database，不然看不到表数据**\n\n\n\n![image-20210913112202575](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500556.png)\n\n\n\n> **这样就OK了**\n\n![image-20210913112435055](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500427.png)\n\n# 关于连接其它数据库\n\n> **连接其他数据库的时候，自定义性没有那么强，可以从支持的数据库中选择，上面连接kingbase数据库自定义性较强，使用DataGrip比较方便，对于MySQL这些比较常用的，使用我们比较熟悉的SQLYog、Naviate即可。**\n\n\n\n![image-20210913112521317](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021501149.png)\n\n![image-20210913112949157](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021501799.png)","tags":["kingbase"]},{"title":"mysql和oorcale日期区间查询【含左右区间问题】","url":"/2021/12/13/mysql和oorcale日期区间查询【含左右区间问题】/","content":"\n# mysql和oorcale日期区间查询【含左右区间问题】\n\n> **直接看样例↓**\n\n\n**mysql：**\n\n```sql\n\n-- 查询区间[2021-12-01,2021-12-03)\nSELECT * FROM b WHERE b.trigger_time >= '2021-12-01' \nAND b.trigger_time <= '2021-12-03'\n\n-- 查询区间[2021-12-01,2021-12-03]\nSELECT * FROM b WHERE to_days( b.trigger_time ) >= to_days( '2021-12-01' ) \nAND to_days( b.trigger_time ) <= to_days( '2021-12-03' )\n\t\n```\n\n<!-- more -->\n\n**orcale：**\n\n```sql\n\n-- 查询区间[2021-12-01,2021-12-03)\nSELECT * FROM b WHERE b.trigger_time >= to_date( '2021-12-01', 'yyyy-MM-dd' ) \nAND b.trigger_time <= to_date( '2021-12-03', 'yyyy-MM-dd' )\n\n\n-- 查询区间[2021-12-01,2021-12-03]\nSELECT * FROM b WHERE to_char( b.trigger_time, 'yyyy-MM-dd' ) >= '2021-12-01' \nAND to_char( b.trigger_time, 'yyyy-MM-dd' ) <= '2021-12-03'\n\n```\n\n>**以上就是mysql和oorcale日期区间查询【含左右区间问题】的全部内容**\n\n>**版权声明：**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.blog.csdn.net/](https://keafmd.blog.csdn.net/)**\n\n\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["mysql"]},{"title":"规范【锦上添花系列】","url":"/2021/10/25/规范【锦上添花系列】/","content":"\n\n\n>**我们提交代码时，有时可能没有什么格式，就简单记录下这次提交了哪部分代码，但是当我们看gitee和github上的提交时就会发现，在提交信息前会有一些单词，那就是用来标识这次提交代码的类别的。**\n\n**规范的好处：**\n- **首先可读性强，不比深看代码，即可知道本次commit的作用**\n- **便于根据项目开发历史**\n- **提高项目整体质量，提高个人专业性**\n- **为Code Reviewing做准备**\n- ...\n\n<!-- more -->\n\n**规范有很多种，本文介绍目前使用最广泛的Angular 规范**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0210eac7b05f4bc38b0a04fcd36c9a96.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54mb5ZOE5ZOE55qE5p-v5Y2X,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n>**关于commit的类别，Angular 规范提到了七种标识：**\n- **feat：最常用的，开发新功能**\n- **fix：也常用，修复bug**\n- **docs：文档**\n- **style：常用，格式修改（不改变代码运行）**\n- **refactor：重构，改变代码结构，不是新功能也不是修复bug**\n- **test：测试**\n- **chore：维护，一些其它修改**\n\n\n>**版权声明：**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.blog.csdn.net/](https://keafmd.blog.csdn.net/)**\n\n\n\n**看完如果对你有帮助，感谢点击下面的==一键三连==支持！\n[哈哈][抱拳]**\n![请添加图片描述](https://img-blog.csdnimg.cn/e76df83ccd6d4e139968fbb68f7b1f99.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["git"]},{"title":"浅显理解Java泛型的super和extends","url":"/2021/08/06/浅显理解Java泛型的super和extends/","content":"\n\n\n# 浅显理解Java泛型的super和extends\n\n# 目录\n\n## 概念简单理解\n\n- List<? extends T>表示该集合中存在的都是类型T的子类，包括T自己\n\n- List<? super T>表示该集合中存的都是类型T的父类，包括T自己\n\n<!-- more -->\n\n## 代码样例解读\n\n==**父子类代码：**==\n\n```java\n/**\n * 生物\n */\nstatic class Biological{\n}\n\n/**\n * 动物\n */\nstatic class Animal extends Biological{\n}\n\n/**\n * 植物\n */\nstatic class Plant extends Biological{\n}\n\n\nstatic class Dog extends Animal{\n}\n\nstatic class Cat extends Animal{\n}\n\nstatic class Flower extends Plant{\n}\n\nstatic class Tree extends Plant{\n}\n```\n\n\n\n**==关系图：==**\n\n![fanxing](https://gitee.com/Keafmd/drawing-bed/raw/master/img/20210804161818.png)\n\n\n\n**==测试代码：==**\n\n```java\npublic static void main(String[] args) {\n\n    List<? super Animal> listA = new ArrayList<>();\n    List<? extends Plant> listB = new ArrayList<>();\n\n    //listA.add(new Biological());  \n    listA.add(new Animal());\n    listA.add(new Dog());\n    //listA.add(new Flower());\n    Object object = listA.get(0);\n\n    //listB.add(new Plant());\n    //listB.add(new Flower());\n    listB.add(null);\n    Plant plant = listB.get(0);\n\n}\n```\n\n## 关于List<? super T>\n\n### add方面\n\n```java\nList<? super Animal> listA = new ArrayList<>();\n```\n\n```\nlistA.add(new Biological());  \n```\n\n执行上面这行代码是不允许的，因为listA的集合类型是Animal或者更高的父类，想一下如果代表的类型是Animal，那怎么允许add它的父类Biological呢？当然不允许了。\n\n```java\nlistA.add(new Animal());\nlistA.add(new Dog());\n```\n\n执行上面这两句就是可以正常执行的，因为无论是Animal还是Animal的子类Dog，都是可以存到集合类型是Animal或者更高的父类的集合中的。有点拗口，不过就是这个意思。\n\n```java\nlistA.add(new Flower());\n```\n\n添加Flower当然是不可以的，因为它不是Animal的子类。\n\n### 返回值方面\n\n```java\nObject object = listA.get(0);\n```\n\n因为listA的集合类型是Animal或者更高的父类，所以不清楚到底会是哪个类，但是我们都应该清楚所有类的父类都是Object，所以返回值是Object类型的。\n\n## 关于List<? extendsT>\n\n### add方面\n\n```java\nList<? extends Plant> listB = new ArrayList<>();\n```\n\n```java\nlistB.add(new Plant());\n```\n\n执行上面的代码是不允许的，因为listB的集合类型是Plant或Plant的子类，想一下如果代表的类型是Plant的子类Tree，那么怎么可能可以add它的父类Plant呢？所以跟上面的那个理解差不多，就是反过来理解。看图可以更加清晰。\n\n```java\nlistB.add(new Flower());\n```\n\n这个同理，如何代表的类型是Flower的子类Rose(玫瑰花)，这样当然不可以add它的父类Flower了。\n\n```java\nlistB.add(null);\n```\n\n特殊情况就是这个，可以add null，但是也没意义啊。\n\n### 返回值方面\n\n```java\nPlant plant = listB.get(0);\n```\n\n因为listB的集合类型是Plant或者它的子类，所以不清楚到底会是哪个类，但是我们可以知道，最高的类型就是Plant了，所以返回值就是Plant类型的。\n\n## 总结\n\n- List<? super T>表示该集合中存的都是类型T的父类，包括T自己\n\n  - add：不能add任何对象（特例：可以添加null）\n\n- get：get返回的对象类型为T\n\n- List<? extends T>表示该集合中存在的都是类型T的子类，包括T自己\n\n  - add：只能添加T及T的子类\n\n  - get：get返回的对象类型为Object\n\n    \n\n  ","tags":["java"]},{"title":"日常Java练习题（每天进步一点点系列）","url":"/2021/05/13/日常Java练习题（每天进步一点点系列）/","content":"\n\n\n**==提示==：好多小伙伴反映，直接看到答案不太好，那我把答案的颜色设置为透明，答案位置还是在题目后面，需要鼠标选中才能看见（操作如下图），同时为了手机端的小伙伴，我还会把所有答案放到文章最下面，希望给每天进步一点点的小伙伴更好的体验，==末尾还有福利==。**\n\n\n\n<!-- more -->\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210513143525820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n**==1==、以下程序段的输出结果为：\npublic class EqualsMethod\n{\n    public static void main(String[] args)\n    {\n        Integer n1 = new Integer(47);\n        Integer n2 = new Integer(47);\n        System.out.print(n1 == n2);\n        System.out.print(\",\");\n        System.out.println(n1 != n2);\n    }\n}\n<font color = white>正确答案: B   你的答案: B (正确)</font>\nfalse，false\nfalse，true\ntrue，false\ntrue，true**\n\n>**题解：\n>首先 我们要知道 `==` 这个比较符号\n>`==`可用于基本类型和引用类型：当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同。\n>\"==\"和 \"!=\"比较的是地址 指第一个new()出来的地址\n>因为两次new() 出的内存也不同\n>所以System.out.print(n1 == n2);返回 false\n>所以System.out.println(n1 != n2);就返回true\n>所以选B**\n\n**==2==、在java7中，下列不能做switch()的参数类型是？\n<font color = white>正确答案: D   你的答案: D (正确)</font>\nint型\n枚举类型\n字符串\n浮点型**\n\n>**题解：\n>switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。**\n\n**==3==、以下代码的输出结果是？\npublic class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n<font color = white>正确答案: C   你的答案: C (正确)</font>\n静态块 构造块 构造块 构造块\n构造块 静态块 构造块 构造块\n构造块 构造块 静态块 构造块\n构造块 构造块 构造块 静态块**\n\n>**题解：\n>开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出''构造块''）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出'构造块'），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出'静态块'），接着执行，main方法，同样也，new了对象，调用构造函数输出（'构造块'），所以选C**\n\n**==4==、What results from the following code fragment?\n（翻译：下面的代码片段产生了什么结果？）\nint i = 5;\nint j = 10;\nSystem.out.println(i + ~j);\n<font color = white>正确答案: C   你的答案: C (正确)</font>\nCompilation error because”~”doesn’t operate on integers\n-5\n-6\n15**\n\n>**题解：\n>公式-n=~n+1可推出~n=-n-1，所以~10=-11再加5结果为-6**\n\n**==5==、对于构造方法，下列叙述正确的是（ ）。\n<font color = white>正确答案: A C D   你的答案: A C D(正确)</font>\n构造方法的优先级一般比代码块低。\n构造方法的返回类型只能是void型。\n构造方法的主要作用是完成对类的对象的初始化工作。\n一般在创建新对象时，系统会自动调用构造方法。**\n\n>**题解：\n>A：静态成员变量或静态代码块>main方法>非静态成员变量或非静态代码块>构造方法\n>B：think in java中提到构造器本身并没有任何返回值。\n>C: 构造方法的主要作用是完成对类的对象的初始化工作。\n>D: 一般在创建(new)新对象时，系统会自动调用构造方法。**\n\n**==6==、JDK1.7版本之前，接口和抽象类描述正确的有（ ）\n<font color = white>正确答案: B C   你的答案: B C (正确)</font>\n抽象类没有构造函数。\n接口没有构造函数。\n抽象类不允许多继承。\n接口中的方法可以有方法体。**\n\n>**题解：\n>A.抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已\n>B.在接口中 不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors。\n>C.Java不允许类多重继承\n>D.jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体**\n\n**==7==、以下关于JAVA语言异常处理描述正确的有？\n<font color = white>正确答案: C D   你的答案: C D (正确)</font>\nthrow关键字可以在方法上声明该方法要抛出的异常。\nthrows用于抛出异常对象。\ntry是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。\nfinally语句块是不管有没有出现异常都要执行的内容。\n在try块中不可以抛出异常**\n\n>**题解：\n>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。\n>throw用于抛出异常。\n>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。\n>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。\n>cacth用于捕获从try中抛出的异常并作出处理。\n>finally语句块是不管有没有出现异常都要执行的内容。**\n\n**==8==、下面程序输出结果为（）：\npublic class Demo{\npublic static void main (String [] args) {\nString lx = “LeXin”;\nString nb = lx;\nlx = “Fenqile”;\nSystem.out.println(nb);\n}\n}\n<font color = white>正确答案: B C   你的答案: B C (正确)</font>\n程序异常，编译不通过\n程序编写正常，可正常运行\n程序输出值为“LeXin”\n程序输出值为“Fenqile”**\n\n>**题解：\n>很显然是把“LeXin”的值赋给了nb**\n\n**==9==、java中关于继承的描述正确的是（）\n<font color = white>正确答案: A C D   你的答案: A C D (正确)</font>\n一个子类只能继承一个父类\n子类可以继承父类的构造方法\n继承具有传递性\n父类一般具有通用性，子类更具体**\n\n>**题解：\n>子类不可以继承父类的构造方法，只可以调用父类的构造方法。子类中所有的构造函数都会默认访问父类中的空参数构造函数，这是因为子类的构造函数内第一行都有默认的super（）语句。**\n\n**==10==、What is Static Method in Java（）\n<font color = white>正确答案: A B C   你的答案: A B C (正确)</font>\nIt is a method which belongs to the class and not to the object(instance)\nA static method can access only static data. It can not access non-static data (instance variables)\nA static method can call only other static methods and can not call a non-static method from it.\nA static method can not be accessed directly by the class name and doesn’t need any object**\n\n>**题解：\n>A：静态方法是一个属于类而不属于对象(实例)的方法。（√）\n>B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）\n>C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）\n>D：静态方法不能通过类名直接访问，也不需要任何对象。（×） 静态方法可以直接用类名访问。**\n\n\n\n**<font color =#40b1f7>最近很多小伙伴希望我推荐个比较详细的Java零基础教程，下面这个是我看过的觉得挺不错的，值得收藏系列。\n链接：[点这里也可以](https://www.bilibili.com/video/BV1Rx411876f)\nhttps://www.bilibili.com/video/BV1Rx411876f</font>**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210513145838608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**答案汇总：\n1、正确答案: B\n2、正确答案: D\n3、正确答案: C\n4、正确答案: C\n5、正确答案:  A C D\n6、正确答案: B C\n7、正确答案: C D\n8、正确答案: B C\n9、正确答案: A C D\n10、正确答案:A B C** \n\n\n\n>**以上部分题解来自牛客评论区，感谢评论区大佬的解释。**\n\n>**每天进步一点点！\n>不进则退！**\n\n**看完如果对你有帮助，感谢点赞支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["每天进步一点点系列"]},{"title":"SpringBoot集成使用jsp（超详细）","url":"/2021/04/06/SpringBoot集成使用jsp（超详细）/","content":"\n\n\n# 添加依赖\n>**SpringBoot-starter-web内嵌的Tomcat无法解析jsp（Thymeleaf），需要额外添加类库：Jasper**\n\n```xml\n<!-- 解析jsp类库  -->\n<dependency>\n    <groupId>org.apache.tomcat.embed</groupId>\n    <artifactId>tomcat-embed-jasper</artifactId>\n</dependency>\n```\n\n<!-- more -->\n\n# 添加上下文目录\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154650281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154835620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154918102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155329817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**中途会提示是否生成文件夹，确认下就行了，最后会多个webapp文件夹，效果如下↓**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155525552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 指定SpringBoot的启动目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155626295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**添加上`$ContentRoot$`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155706249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# 设置application.properties\n\n```java\n#页面默认前缀目录 默认在webapp下有别的文件夹可以，以文件夹/往下加\nspring.mvc.view.prefix=/\n#页面默认后缀目录\nspring.mvc.view.suffix=.jsp\n```\n\n# 测试是否可行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040216000554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**ViewController：**==\n```java\npackage com.keafmd.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n/**\n * Keafmd ！\n *\n * @ClassName: ViewController\n * @Description:\n * @author: 牛哄哄的柯南\n * @Date: 2021-04-02 14:47\n * @Blog: https://keafmd.blog.csdn.net/\n */\n@Controller\npublic class ViewController {\n\n    @GetMapping(\"getname\")\n    public String getName(Model model){\n        model.addAttribute(\"name\",\"keafmd\");\n        return \"name\";\n    }\n    @GetMapping(\"getage\")\n    public String getAge(Model model){\n        model.addAttribute(\"age\",18);\n        return \"age\";\n    }\n}\n```\n**在webapp下创建name.jsp和age.jsp**\n\n==**name.jsp：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: lenovo\n  Date: 2021/4/2\n  Time: 14:31\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<h1>name</h1>\n${name}\n\n</body>\n</html>\n```\n\n==**age.jsp：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: lenovo\n  Date: 2021/4/2\n  Time: 15:29\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<h1>age</h1>\n${age}\n\n</body>\n</html>\n```\n\n**----------启动程序----------**\n\n**访问：`http://127.0.0.1:8080/getage`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402160347237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**访问：`http://127.0.0.1:8080/getname`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402160420110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**搞定！**\n\n>**以上就是SpringBoot集成使用jsp（超详细）的全部内容。**\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n![](https://gitee.com/Keafmd/drawing-bed/raw/master/img/timg7L0CY2U1.jpg)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["SpringBoot"]},{"title":"Mybatis的动态SQL语句","url":"/2021/02/13/Mybatis的动态SQL语句/","content":"\n# 项目目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021021221312397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n\n<!-- more -->\n\n\n\n# 动态 SQL 之if标签\n\n## 持久层 Dao 接口\n\n```java\n/**\n * 根据传入的参数条件\n * @param user 查询的条件，有可能有用户名 ，性别，或都没有\n * @return\n */\nList<User> finduserCondition(User user);\n```\n## 持久层 Dao 映射配置\n\n```xml\n<!--根据条件查询-->\n<select id=\"finduserCondition\" resultMap=\"userMap\" parameterType=\"user\">\n    select * from user where 1=1\n    <if test=\"userName != null\">\n        and username = #{userName}\n    </if>\n    <if test=\"userSex != null\">\n        and sex = #{userSex}\n    </if>\n</select>\n```\n## 测试代码\n\n```java\n/**\n * 根据条件查询 if标签\n * @throws Exception\n */\n@Test\npublic void testfinduserCondition() throws Exception {\n\n    User u = new User();\n    u.setUserName(\"老王\");\n    u.setUserSex(\"男\");\n    //5.使用代理对象执行方法\n    List<User> users = userDao.finduserCondition(u);\n    for (User user : users) {\n        System.out.println(user);\n    }\n\n}\n```\n==**测试结果：**==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210212211927937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 动态 SQL 之where标签\n>**为了简化上面 where 1=1 的条件拼装，我们可以采用`<where>`标签来简化开发。**\n\n## 持久层 Dao 映射配置\n```xml\n<select id=\"finduserCondition\" resultMap=\"userMap\" parameterType=\"user\">\n    select * from user\n    <where>\n        <if test=\"userName != null\">\n            and username = #{userName}\n        </if>\n        <if test=\"userSex != null\">\n            and sex = #{userSex}\n        </if>\n    </where>\n</select>\n```\n>**效果和上面的if标签一样**\n\n# 动态 SQL 之foreach标签\n## 需求\n>**传入多个 id 查询用户信息，用下边两个 sql 实现：\n>SELECT * FROM USERS WHERE username LIKE '%王%' AND (id =10 OR id =19 OR id=36)\n>SELECT * FROM USERS WHERE username LIKE '%王%' AND id IN (10,19,36)**\n>**这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。**\n\n## 在 QueryVo 中加入一个 List 集合用于封装参数\n==**QueryVo：**==\n```java\npackage com.keafmd.domain;\n\nimport java.util.List;\n\n/**\n * Keafmd\n *\n * @ClassName: QueryVo\n * @Description:\n * @author: 牛哄哄的柯南\n * @date: 2021-02-08 21:08\n */\npublic class QueryVo {\n    private  User user;\n    private List<Integer> ids;\n\n    public List<Integer> getIds() {\n        return ids;\n    }\n\n    public void setIds(List<Integer> ids) {\n        this.ids = ids;\n    }\n\n    public User getUser() {\n        return user;\n    }\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n}\n```\n## 持久层 Dao 接口\n```java\n/**\n * 根据QueryVo中提供的id集合查询\n * @param vo\n * @return\n */\nList<User> findUserInIds(QueryVo vo);\n```\n\n## 持久层 Dao 映射配置\n\n```xml\n<!--根据QueryVo中的id集合实现查询查询用户列表-->\n<select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\">\n    <include refid=\"defaultUser\"></include>\n    <where>\n        <if test=\"ids!=null and ids.size()>0\">\n            <foreach collection=\"ids\" open = \"and id in (\" close=\")\" item=\"uid\" separator=\",\">\n                #{uid}\n            </foreach>\n\n        </if>\n    </where>\n</select>\n```\n## 测试代码\n\n```java\n@Test\npublic void testfindUserInIds() throws Exception {\n\n    QueryVo vo = new QueryVo();\n    List<Integer> list = new ArrayList<Integer>();\n    list.add(41);\n    list.add(42);\n    list.add(50);\n    vo.setIds(list);\n\n    //5.使用代理对象执行方法\n    List<User> users = userDao.findUserInIds(vo);\n    for (User user : users) {\n        System.out.println(user);\n    }\n\n}\n```\n==**测试结果：**==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021021221354223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# Mybatis中简化编写的 SQL 片段\n>**Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。**\n>**这样可以简化我们每次都需要在sql语句中写的`select * from user`。**\n\n## 定义代码片段\n\n```xml\n<!--了解的内容，抽取重复的sql语句-->\n<sql id=\"defaultUser\">\n    select * from user\n</sql>\n```\n>**==注意细节==：在抽取重复的sql语句尽量不要写分号`;`,因为可能还会和后面的sql语句进行拼接，有分号就会导致报错。**\n\n\n## 引用代码片段\n\n```xml\n<!--配置查询所有-->\n<select id=\"findAll\" resultMap=\"userMap\">\n    <include refid=\"defaultUser\"></include>\n</select>\n\n<!--根据QueryVo中的id集合实现查询查询用户列表-->\n<select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\">\n     <include refid=\"defaultUser\"></include>\n     <where>\n         <if test=\"ids!=null and ids.size()>0\">\n             <foreach collection=\"ids\" open = \"and id in (\" close=\")\" item=\"uid\" separator=\",\">\n                 #{uid}\n             </foreach>\n\n         </if>\n     </where>\n</select>\n```\n\n>**以上就是Mybatis的动态SQL语句的全部内容。**\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["Mybatis"]},{"title":"解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题","url":"/2021/01/30/解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题/","content":"\n### 有些时候我们会看到错误日志，显示没有权限访问tomcat下的某某目录，或者用tomcat时报出了一些错误，极有可能和我们的tomcat文件夹存在访问权限的问题有关！我们试一下在tomcat下的某些目录，特别是在temp文件夹下创建文件，看是否需要管理员权限，有时我们把tomcat装到了系统盘，就会显示需要管理员权限才可以创建文件，这样会导致很多情况下提示在tomcat的目录下存在访问权限的问题。\n\n\n\n# <font color=red>解决办法：</font>\n\n<!-- more -->\n\n **进到tomcat所在的文件夹，我的是：D:\\Program Files\\apache\\apache-tomcat-8.5.60（我的D盘是当初C盘分出来的，所以存在权限问题）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225015329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n **在apache目录下：==鼠标右键-->属性-->安全-->编辑==把==ALL APPLICATION PACKAGES==和==User(xxxx\\Users)==下的访问权限==全部允许==就可以了，基本上就是==完全控制和修改==没有打上勾，勾上就可以了。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225818409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225745956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n **这样基本就可以解决很多时候由于访问tomcat而导致的权限问题了。**\n\n>**以上就是解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题的全部内容。**\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["tomcat"]},{"title":"Spring入门案例【spring框架创建对象】（超详细）","url":"/2021/01/26/Spring入门案例【spring框架创建对象】（超详细）/","content":"\n# Spring框架概述\n**（1）Spring是轻量级的开源的JavaEE框架。\n（2）Spring可以解决企业应用开发的复杂性。\n（3）Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。\n（4）<font color=red>Spring有两个核心部分：IOC和AOP\n&nbsp; &nbsp;&nbsp;1、IOC：控制反转，把创建对象的过程交给Spring进行管理。\n  &nbsp;&nbsp; &nbsp;2、AOP：面向切面，不修改源代码进行功能增强。</font>**\n\n<!-- more -->\n\n# Spring框架特点\n**（1）方便解耦，简化开发。\n（2）AOP编程支持。\n（3）方便程序测试。\n（4）方便和其他框架进行整合。\n（5）方便进行事务操作。\n（6）降低API开发难度。**\n\n# 准备过程\n**本文是按照spring-5.2.6进行演示。**\n## 下载 spring-5.2.6.RELEASE-dist.zip\n**下载地址：[ spring-5.2.6](https://repo.spring.io/release/org/springframework/spring/5.2.6.RELEASE/)**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114231911473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n## 下载 commons-logging-1.2-bin.zip\n**下载地址：[commons-logging-1.2](http://commons.apache.org/proper/commons-logging/download_logging.cgi)**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232119862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n## 把两个zip解压挑选核心基础的五个jar包放到新创建的文件夹中\n**如下图所示即可，创建个新的文件夹core用于存放核心基础的五个jar包。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232403922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**从 spring和commons中复制出来这五个。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232708594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**Spring中四个jar包的路径：spring-framework-5.2.6.RELEASE\\libs下**\n**从这里面复制出来放到core里面**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232921741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**commons中一个jar包的路径：commons-logging-1.2下**\n**把这个复制出来放到core里面**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233108249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**操作完成以上步骤后就可以进入idea操作了**\n\n# 创建一个新的Java项目\n**New Project**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233421875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**勾选上继续下一步**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233511869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**写个项目名，Base package根据自己想命名的改，也可以不改，Finish。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233643327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# 创建lib文件夹，导入jar包\n**在这个位置创建好lib文件夹后，直接从刚才准备好的core文件夹中把那五个核心jar包复制粘贴过来即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234353903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 添加依赖\n**1、如图所示点击打开。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234639631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**2、继续按图操作**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234747976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**3、找到lib把那五个jar包全部选中点击OK**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234915642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**4、这样就导入进来了然后点击**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114235234132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n# 创建个User类\n**有一些是我写的其它的，忽略即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234156235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**User类代码：**==\n\n```java\npackage com.Keafmd.spring5;\n\n/**\n * Keafmd\n *\n * @ClassName: User\n * @Description: User类\n * @author: 牛哄哄的柯南\n * @date: 2021-01-14 19:58\n */\npublic class User {\n\n\t//只写个方法就行了\n    public  void add(){\n        System.out.println(\"add....\");\n    }\n}\n```\n# 在src下创建bean1.xml\n**我的写的有些其它内容，具体代码看下面的代码即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011423552534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n==**bean1.xml：**==\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 添加这一行就可以了,配置User对象的创建-->\n    <bean id=\"user\" class=\"com.Keafmd.spring5.User\"></bean>\n\n</beans>\n```\n\n# 创建测试样例\n**在如图位置创建即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115000039864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**测试代码：**==\n\n```java\npackage com.Keafmd.spring5.testdemo;\n\nimport com.Keafmd.spring5.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * Keafmd\n *\n * @ClassName: TestSpring5\n * @Description:\n * @author: 牛哄哄的柯南\n * @date: 2021-01-14 20:06\n */\npublic class TestSpring5 {\n\t//写完 @Test有红色提醒是因为没导入，直接导入就可以了。\n    @Test\n    public void testAdd(){\n        //1、载Spring的配置文件\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean1.xml\");\n\n        //2、获取配置文件中创建的对象  默认是执行无参的构造方法创建\n        User user =applicationContext.getBean(\"user\", User.class);\n\n        System.out.println(user);\n        user.add();\n\n    }\n}\n```\n\n==**测试结果：**==\n```java\ncom.Keafmd.spring5.User@150c158\nadd....\n\nProcess finished with exit code 0\n```\n**运行测试代码，输出user对象的地址和add方法的输出语句就证明完成了入门案例。Spring的核心思想是IOC，即所有对象的创建都是通过Spring，而不需要自己手动生成，这样我们就完成了用spring框架创建对象的入门案例。**\n\n**写作不易，看完如果对你有帮助，感谢点赞支持！\n如果你是电脑端，看到右下角的 “==一键三连==” 了吗，没错点它[哈哈]**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**"},{"title":"SpringMVC中常用注解（案例讲解）","url":"/2021/01/25/SpringMVC中常用注解（案例讲解）/","content":"\n### SpringMVC中常用注解\n\n<!-- more -->\n\n# RequestParam\n\n<font size =5>**说明**</font>\n>**==作用：==\n>把请求中指定名称的参数给控制器中的形参赋值。\n>==属性：==\n>value：请求参数中的名称。\n>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: Keafmd\n  Date: 2021/1/25\n  Time: 10:48\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>常用注解</title>\n</head>\n<body>\n\n    <!-- requestParams 注解的使用 -->\n    <a href=\"anno/testRequestParam?name=keafmd\">RequestParam</a><br/>\n\n</body>\n</html>\n```\n==**控制器代码：**==\n\n```java\npackage com.Keafmd.controller;\n\nimport com.Keafmd.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.bind.support.SessionStatus;\n\nimport java.util.Date;\nimport java.util.Map;\n\n/**\n * Keafmd\n *\n * @ClassName: AnnoConteoller\n * @Description: 注解的控制器\n * @author: 牛哄哄的柯南\n * @date: 2021-01-25 10:50\n */\n@Controller\n@RequestMapping(\"/anno\")\npublic class AnnoConteoller {\n\n    /**\n     * requestParams 注解的使用\n     * @param username\n     * @return\n     */\n    @RequestMapping(\"/testRequestParam\")\n    public String testRequestParam(@RequestParam(value=\"name\") String username){\n        // @RequestParam(value=\"name\") 必须传name,required：请求参数中是否必须提供此参数，默认值是true，必须提供\n        // 获得当前类名\n        String clazz = Thread.currentThread().getStackTrace()[1].getClassName();\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n\n        System.out.println(\"执行了：\"+clazz+\" - \"+method);\n        System.out.println(\"username:\"+username);\n        return \"success\";\n    }\n\n}\n```\n==**输出结果：**==\n\n```java\n执行了：com.Keafmd.controller.AnnoConteoller - testRequestParam\nusername:keafmd\n```\n\n>**这样我们在href中传入name就会赋值给username。**\n\n# RequestBody\n<font size =5>**说明**</font>\n>**==作用：==\n>用于获取请求体内容。直接使用得到是 key=value&key=value...结构的数据。\n>get 请求方式不适用。\n>==属性：==\n>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<form action=\"anno/testRequestBody\" method=\"post\">\n        用户姓名：<input type=\"text\" name=\"uname\" /><br/>\n        用户年龄：<input type=\"text\" name=\"age\" /><br/>\n        用户生日：<input type=\"text\" name=\"birthday\" /><br/>\n        <input type=\"submit\" value=\"提交\">\n</form>\n```\n==**控制器代码：**==\n\n```java\n/**\n* 获取到请求体的内容 RequestBody\n */\n\n@RequestMapping(\"/testRequestBody\")\npublic String testRequestBody(@RequestBody String body){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(\"body:\"+body);\n    return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testRequestBody\nbody:uname=Keafmd&age=21&birthday=2000-01-01\n```\n# PathVaribale\n\n## 先了解下REST 风格 URL\n\n>**REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。**\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/20210125191242816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。\n>url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。\n>==属性：==\n>value：用于指定 url 中占位符名称。\n>required：是否必须提供占位符。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testPathVariable/10\">testPathVariable</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n* PathVariable\n* @param id\n* @return\n*/\n@RequestMapping(\"/testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(name=\"sid\") String id){\n   // 获得当前方法名\n   String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n   System.out.println(\"执行了：\"+\" \"+method);\n   System.out.println(\"id:\"+id);\n   return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testPathVariable\nid:10\n```\n# RequestHeader\n<font size =5>**说明**</font>\n>**==作用：==\n>用于获取请求消息头。\n>==属性：==\n>value：提供消息头名称\n>required：是否必须有此消息头\n>==提示：==\n>在实际开发中一般不常用**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testRequestHeader\">testRequestHeader</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n* RequestHeader获取请求头的值  不常用\n* @param head\n* @return\n*/\n@RequestMapping(\"/testRequestHeader\")\npublic String testRequestHeader(@RequestHeader(value = \"Accept\") String head){\n   // 获得当前方法名\n   String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n   System.out.println(\"执行了：\"+\" \"+method);\n\n   System.out.println(\"head:\"+head);\n   return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testRequestHeader\nhead:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n```\n# CookieValue\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于把指定 cookie 名称的值传入控制器方法参数。\n>==属性：==\n>value：指定 cookie 的名称。\n>required：是否必须有此 cookie。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testCookieValue\">testCookValue</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n * CookieValue 不常用\n * @param cookievalue\n * @return\n */\n@RequestMapping(\"/testCookieValue\")\npublic String testCookieValue(@CookieValue(value = \"JSESSIONID\") String cookievalue){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n\n    System.out.println(\"cookievalue:\"+cookievalue);\n    return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testCookieValue\ncookievalue:DCCFE2C1F975AC04D4F55973ADA5C89C\n```\n\n# ModelAttribute\n\n<font size =5>**说明**</font>\n>**==作用：==\n>该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。\n>出现在方法上，表示==当前方法会在控制器的方法执行之前，先执行==。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。\n>出现在参数上，获取指定的数据给参数赋值。\n>==属性：==\n>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。\n>==应用场景：==\n>当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n```java\n<form action=\"anno/testModelAttribute\" method=\"post\">\n\t用户姓名：<input type=\"text\" name=\"uname\" /><br/>\n    用户年龄：<input type=\"text\" name=\"age\" /><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n## 修饰的方法有返回值\n==**控制器代码：**==\n\n```java\n/**\n * ModelAttribute\n * @return\n */\n\n@RequestMapping(\"/testModelAttribute\")\npublic String testModelAttribute(User user){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(user);\n    return \"success\";\n}\n\n//有返回值\n@ModelAttribute\npublic User showUser(String uname){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    User user = new User();\n    user.setUname(uname);\n    user.setAge(20);\n    user.setBirthday(new Date());\n    return user;\n}\n```\n==**输出结果：**==\n```java\n执行了： testModelAttribute\nUser{uname='牛哄哄的柯南', age=21, birthday=Mon Jan 25 19:34:46 CST 2021}\n```\n\n\n## 修饰的方法没有返回值\n>**==注意==：没有返回值的时候利用Map把参数传回去，testModelAttribute的参数User前加上@ModelAttribute(\"abc\")接收Map传回的数据。**\n\n==**控制器代码：**==\n\n```java\n/**\n * ModelAttribute\n * @return\n */\n\n@RequestMapping(\"/testModelAttribute\")\npublic String testModelAttribute(@ModelAttribute(\"abc\")User user){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(user);\n    return \"success\";\n}\n\n//无返回值\n@ModelAttribute\npublic void showUser(String uname, Map<String,User> map){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    User user = new User();\n    user.setUname(uname);\n    user.setAge(20);\n    user.setBirthday(new Date());\n    map.put(\"abc\",user);\n}\n```\n\n\n==**输出结果：**==\n```java\n执行了： testModelAttribute\nUser{uname='牛哄哄的柯南', age=21, birthday=Mon Jan 25 19:32:20 CST 2021}\n```\n\n# SessionAttribute\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于多次执行控制器方法间的参数共享。\n>==属性：==\n>value：用于指定存入的属性名称\n>type：用于指定存入的数据类型。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n```java\n<a href=\"anno/testSessionAttributes\">存入SessionAttributes</a><br/>\n<a href=\"anno/getSessionAttributes\">获取SessionAttributes</a><br/>\n<a href=\"anno/delSessionAttributes\">清除SessionAttributes</a><br/>\n```\n==**控制器代码：**==\n>**注意：需要在类的上面添加`@SessionAttributes(value = {\"msg\"}) //把msg=牛哄哄的柯南存到session域中`。**\n\n```java\npackage com.Keafmd.controller;\n\nimport com.Keafmd.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.bind.support.SessionStatus;\n\nimport java.util.Date;\nimport java.util.Map;\n\n/**\n * Keafmd\n *\n * @ClassName: AnnoConteoller\n * @Description: 注解的控制器\n * @author: 牛哄哄的柯南\n * @date: 2021-01-25 10:50\n */\n@Controller\n@RequestMapping(\"/anno\")\n@SessionAttributes(value = {\"msg\"}) //把msg=牛哄哄的柯南存到session域中\npublic class AnnoConteoller {\n\n    /**\n     * SessionAttributes注解，存入msg\n     * @return\n     */\n    @RequestMapping(\"/testSessionAttributes\")\n    public String testSessionAttributes(Model model){\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //底层会存到Request域中\n        model.addAttribute(\"msg\",\"牛哄哄的柯南\");\n\n        return \"success\";\n    }\n\n    /**\n     * 获取\n     * @param modelMap\n     * @return\n     */\n    @RequestMapping(\"/getSessionAttributes\")\n    public String getSessionAttributes(ModelMap modelMap){\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //从session域中取出来\n        String msg = (String)modelMap.get(\"msg\");\n        System.out.println(msg);\n        return \"success\";\n    }\n\n    /**\n     * 清除\n     * @param sessionStatus\n     * @return\n     */\n    @RequestMapping(\"/delSessionAttributes\")\n    public String delSessionAttributes(SessionStatus sessionStatus) {\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //从session域中清除\n        sessionStatus.setComplete();\n        return \"success\";\n    }\n\n\n}\n\n```\n>**依次点击存入->获取->清除->获取。**\n\n==**输出结果：**==\n```java\n执行了： testSessionAttributes\n执行了： getSessionAttributes\n牛哄哄的柯南\n执行了： delSessionAttributes\n执行了： getSessionAttributes\nnull\n```\n\n>**在success.jsp可以通过`${msg}和${sessionScope}`获取到在类上面把msg存入到session域的内容：`牛哄哄的柯南和{msg=牛哄哄的柯南}`**\n>**在success.jsp可以通过`${requestScope}`获取到在testSessionAttributes方法中存入Request域中的内容。**\n\n>**以上就是SpringMVC中常用注解（案例讲解）的全部内容。**","tags":["Keafmd"]},{"title":"Hello World","url":"/2021/01/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]