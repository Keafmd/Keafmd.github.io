[{"title":"加油站（贪心）","url":"/2022/04/29/加油站（贪心）/","content":"\n# 题目\n\n[加油站](https://leetcode-cn.com/problems/gas-station/)\n\n难度 中等\n\n>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n\n\n\n<!--more-->\n\n> 示例 1:\n>\n> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n> 输出: 3\n> 解释:\n> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油\n> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油\n> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油\n> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油\n> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。\n> 因此，3 可为起始索引。\n\n\n\n> 示例 2:\n>\n> 输入: gas = [2,3,4], cost = [3,4,3]\n> 输出: -1\n>\n> 解释:\n> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。\n> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油\n> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油\n> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油\n> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。\n> 因此，无论怎样，你都不可能绕环路行驶一周。\n\n\n\n> 提示:gas.length == n\n> cost.length == n\n> 1 <= n <= 105\n> 0 <= gas[i], cost[i] <= 104\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        //先排除特殊情况\n        if(gas == null || cost == null || gas.length == 0 || cost.length == 0){\n            return -1;\n        }\n        if(gas.length == 1 && cost[0]== gas[0]){\n            return 0;\n        }\n\n        //剩余的数组\n        int[] last = new int[gas.length];\n\n        //起点的可能位置列表\n        List<Integer> list = new ArrayList<>();\n        int sum = 0;\n        for (int i = 0; i < gas.length; i++) {\n            last[i] = gas[i] - cost[i];\n            sum+=last[i];\n            if(last[i]>0){\n                list.add(i);\n            }\n        }\n        //不可能跑一圈\n        if(sum<0){\n            return -1;\n        }\n        int res = -1;\n        //遍历所有的可能节点\n        for (Integer i : list) {\n            boolean[] flag = new boolean[gas.length];\n            flag[i] = true;\n            int curr = i;\n            int j=0;\n            sum = last[curr];\n            //跑圈\n            for(j=0;j<gas.length;j++){\n                int next = curr+1==gas.length?0:curr+1;\n                sum +=last[next];\n                //油不够了\n                if(sum < 0){\n                    break;\n                }\n                curr = curr+1==gas.length?0:curr+1;\n            }\n            //可以跑一圈\n            if(j==gas.length){\n                return i;\n            }\n\n        }\n        return res;\n\n    }\n}\n```\n\n\n\n**精简代码：**\n\n```java\nclass Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int start = 0, sum = 0, tank = 0;\n        for (int i = 0; i < gas.length; i++) {\n            tank += gas[i] - cost[i];\n            if (tank < 0) {\n                start = i + 1;\n                sum += tank;\n                tank = 0;\n            }\n        }\n        return sum + tank >= 0 ? start : -1;\n\n    }\n}\n```\n\n\n\n","tags":["每天进步一点点系列","贪心"],"categories":["LeetCode"]},{"title":"机器人的运动范围（DFS）","url":"/2022/04/28/机器人的运动范围（DFS）/","content":"\n\n\n# 题目\n\n[机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)\n\n难度 中等\n\n>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n<!--more-->\n\n> 示例 1：\n>\n> 输入：m = 2, n = 3, k = 1\n> 输出：3\n>\n> 示例 2：\n>\n> 输入：m = 3, n = 1, k = 0\n> 输出：1\n\n\n\n> 提示：\n>\n> 1 <= n,m <= 100\n> 0 <= k <= 20\n\n\n\n**代码：**\n\n**Java：**\n\n```java\nclass Solution {\n    //结果\n    int sum =0;\n    public int movingCount(int m, int n, int k) {\n        //初始化一个二维数组表示是否访问过\n        boolean[][] visited = new boolean[m][n];\n        dfs(0,0,m,n,k,visited);\n        return sum;\n    }\n    private void dfs(int i,int j,int m,int n,int k,boolean[][] visited){\n        //判断是否符合条件\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || getSum(i)+getSum(j) > k){\n            return;\n        }\n        //标记访问过了\n        visited[i][j] = true;\n        //结果加1\n        sum++;\n        //深度优先搜索 四个方向\n        dfs(i-1,j,m,n,k,visited);\n        dfs(i+1,j,m,n,k,visited);\n        dfs(i,j-1,m,n,k,visited);\n        dfs(i,j+1,m,n,k,visited);\n    }\n    //计算数位和\n    private int getSum(int num){\n        int sum =0;\n        while(num>0){\n            sum+=num%10;\n            num/=10;\n        }\n        return sum;\n    }\n\n\n}\n```\n\n\n\n**C++：**\n\n```c++\nclass Solution {\npublic:\n    int res = 0;\npublic:\n    int movingCount(int m, int n, int k) {\n        vector<vector<bool>> visited(m, vector<bool>(n, 0));\n        dfs(0, 0, m, n, k, visited);\n        return res;\n    }\n\npublic:\n    void dfs(int i, int j, int m, int n, int k, vector<vector<bool>> &visited) {\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j] || getSum(i) + getSum(j) > k) {\n            return;\n        }\n        visited[i][j] = true;\n        res++;\n        dfs(i + 1, j, m, n, k, visited);\n        dfs(i - 1, j, m, n, k, visited);\n        dfs(i, j + 1, m, n, k, visited);\n        dfs(i, j - 1, m, n, k, visited);\n    }\n\npublic:\n    int getSum(int n) {\n        int sum = 0;\n        while (n) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n};\n```\n\n\n\n","tags":["每天进步一点点系列","DFS"],"categories":["LeetCode"]},{"title":"Linux部署前后端分离项目（SpringBoot+Vue）【Nginx部署】","url":"/2022/04/26/Linux部署前后端分离项目（SpringBoot-Vue）【Nginx部署】/","content":"\n# 需求引入\n\n> 题外话：这种标题网上一搜全是，我为啥还写这篇文章，一是作为笔记，二是可能不同人遇到的问题不一样，处理方案也不同，我多发一篇，就帮助读这篇文章的你多一种部署成功的情况。\n>\n> 这个时候最多的是部署毕设吧，今天有朋友问我，我就整理成一篇文章供大家参考。\n\n需求很简单，就是想把自己写的前后端分离的项目部署到Linux服务器上，我们要准备啥，首先就是前后端分离的一个项目，其次一个安装好nginx和jdk的服务器，我相信你也都有了，才看到这篇文章的，来吧，跟着开始。\n\nLinux安装jdk可以看我的这篇文章：[学妹跑过来抱着我的胳膊让我帮她在Linux上装jdk【手把手教学】](https://blog.csdn.net/weixin_43883917/article/details/117256094)\n\n<!--more-->\n\n# 步骤\n\n## 1、对前端项目的baseURL进行修改\n\n  82是你想在服务器那个端口访问这个项目，自己根据情况更改，XXXX是自己的服务器ip\n\n加个api是为了后面在nginx处理，随便写，不一样非要是api，后面nginx中对应上就行\n\n```\n  // baseURL: 'http://127.0.0.1:8082/pethospital/',\n  baseURL: 'http://XXXX:82/api/pethospital/',\n```\n\n![image-20220426174636615](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204261746333.png)\n\n## 2、打包前端项目\n\n在前端项目所在目录的控制台执行`npm run build`\n\n![image-20220426174930105](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204261749220.png)\n\n然后就会在项目的根目录下生成 `dist` 文件夹，一会再用。\n\n## 3、打包后端项目\n\n注意点说一下，打成jar包（其它什么包都行）但是后面步骤就不同了，就跟着打jar包即可，在pom.xml中加上`spring-boot-maven-plugin`\n\n```xml\n<packaging>jar</packaging>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n    </plugins>\n</build>\n```\n\n\n\n> 控制台执行`mvn clean install -Dmaven.test.skip=true`，打包同时抛弃测试用例。\n\n\n\n![image-20220426175717713](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204261757250.png)\n\n\n\n打包完成后，在target目录下就会出现一个jar包，留着下一步用，还有上面的前端的dist文件夹。\n\n## 4、把jar包和dist文件夹上传的服务器\n\n**用什么工具都行xftp或MobaXterm，为了能跟着搞成，我下面说的可能很细，嫌弃多余跳着看即可，有基础的根据自己情况变更都可以，没经验的就跟着来，至少能成功。**\n\n\n\n在服务器根目录下创建个 文件夹存放 `mkdir pet`，然后把jar包和dist文件夹都移动到这里就行\n\n\n\n![image-20220426185159386](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204261852044.png)\n\n\n\n## 5、修改nginx的配置文件\n\n\n\n我的配置文件目录在 `/etc/nginx`（cd /etc/nginx），编辑`nginx.conf`文件（vim nginx.conf），因为我的里面配置了其它的内容，我都粘贴出来看起来可能更复杂，我截取重点粘出来。\n\n\n\n设置个跳转路径 ，相当于` ip地址/pet` 跳转到 `IP地址:82端口`，这一步不配置也行，直接访问82端口也行。\n\n> :zero: 此处请 <font color=red >注意</font> ：提前把服务器的82端口打开\n\n```\nserver {\n            listen 80;\n                #填写绑定证书的域名\n                server_name XXXX;\n\t\t\t\t...\n\t\t\t\t\n              location /pet {\n                  rewrite ^/(.*) http://XXXX:82;\n              }\n    }\n```\n\n\n\n> :one:<font color = red>注意</font> ：配置到这就把服务器对应的后端项目对应的端口打开，我的后端设置的8083端口\n>\n> 两个注意点：\n>\n> `# 这里就是 dist 的文件位置\n> root /pet/dist;`\n>\n> `# 这里端口对应后端端口\n> proxy_pass http://XXXX:8083;`\n\n```\nhttp{\n...\n\nserver {\n    listen 82;\n    server_name pet;\n\n    location / {\n        # 这里就是 dist 的文件位置\n        root /pet/dist;\n        index index.html;\n        proxy_ssl_session_reuse off;\n        try_files  $uri $uri/ /index.html;\n    }\n    #拦截/api/请求，因为所有的请求在前端被处理成 '/api+后端接口'形式\n    location /api/ {\n        #开启重写日志记录，这个会记录在error.log里面，级别为notice\n        rewrite_log on;\n        #重写规则，可根据实际情况调整。\n        rewrite ^.+api/?(.*)$ /$1 break;\n        # 这里端口对应后端端口\n        proxy_pass http://XXXX:8083;\n        proxy_redirect    off;\n        proxy_set_header  Host $host;\n        proxy_set_header  X-real-ip $remote_addr;\n        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n\n\n}\n\n```\n\n\n\n**执行下面两步：**\n\n校验配置文件：`nginx -t`\n\n重启gninx：`nginx -s reload`\n\n\n\n## 6、启动后端项目\n\n切换到 `/pet` 目录下\n\n启动命令：\n\n`nohup java -Dfile.encoding=utf-8 -jar pet-hospital-0.0.1-SNAPSHOT.jar >> log  2>&1 &`\n\n用nohup可以在窗口关闭时，使程序继续运行，我们也可以写个启动的脚本，这样重启起来方便\n\n> 先 `vim startPet.sh` 编辑脚本\n\n```sh\n#!/bin/bash\npid=(`ps -ef | grep pet | grep -v grep | awk '{print $2}'`)\nif [ -n $pid ]\nthen\n echo \"is null\"\nelse\n ps -ef | grep pet | grep -v grep | awk '{print $2}' | xargs kill\nfi\n\nnohup java -Dfile.encoding=utf-8 -jar pet-hospital-0.0.1-SNAPSHOT.jar >> log  2>&1 &\n```\n\n> 在变成可执行命令：`chmod +x startPet.sh`\n\n> 在执行： `./startPet.sh` （启动或重启）\n\n这样就会参生log和nohup.out文件了，\n\n![image-20220426192659050](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204261927243.png)\n\n\n\n## 7、日志查看\n\n看倒数n行 ： `tail -n 100 log`\n\n一直查看： `tail -f log`\n\n\n\n看下日志后端没问题，基本就是搞定了\n\n\n\n浏览器访问：`服务器ip/pet` 就可以访问看到项目的界面了\n\n\n\n","tags":["Linux","SpringBoot","Vue","Nginx"],"categories":["Linux"]},{"title":"验证回文串","url":"/2022/04/25/验证回文串/","content":"\n\n\n# 题目\n\n[验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)\n\n难度 简单\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n**说明：**本题中，我们将空字符串定义为有效的回文串。\n\n<!-- more -->\n\n> 示例 1:\n>\n> 输入: \"A man, a plan, a canal: Panama\"\n> 输出: true\n> 解释：\"amanaplanacanalpanama\" 是回文串\n>\n> 示例 2:\n>\n> 输入: \"race a car\"\n> 输出: false\n> 解释：\"raceacar\" 不是回文串\n\n\n\n> 提示：1 <= s.length <= 2 * 105\n> 字符串 s 由 ASCII 字符组成\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        //先都转小写\n        s = s.toLowerCase();\n        StringBuilder sCopy = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            //自保留字母和数字\n            if(Character.isLetterOrDigit(s.charAt(i))) {\n                sCopy.append(s.charAt(i));\n            }\n        }\n        //反转字符串\n        StringBuffer sCopy2 = new StringBuffer(sCopy).reverse();\n        //比较\n        return sCopy.toString().equals(sCopy2.toString());\n    }\n}\n```\n\n**C++版：**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        string str;\n        for(char ch : s){\n            // 只考虑字母和数字字符\n            if(isalnum(ch)){\n                // 将字符转换为小写\n                str += tolower(ch);\n            }\n        }\n        /**\n         * c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素\n         * c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置\n         */\n        string str2(str.rbegin(), str.rend());\n        // 判断是否为回文串\n        return str == str2;\n    }\n};\n\nint main() {\n    Solution s;\n    cout << (s.isPalindrome(\"A man, a plan, a canal: Panama\") ?\"true\":\"false\")<< endl;\n    return 0;\n}\n\n```\n\n\n\n\n\n>**以上就是验证回文串的全部内容**\n\n\n\n>**版权声明：keafmd**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.top/](https://keafmd.top/)**\n\n\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["每天进步一点点系列"],"categories":["LeetCode"]},{"title":"配置文件加密（Jasypt的简单使用）","url":"/2022/04/25/配置文件加密（Jasypt的简单使用）/","content":"\n\n\n# 需求引入\n\n当我们需要对SpringBoot项目的配置文件中的信息进行加密时，如数据库密码等，此时我们可以使用Jasypt来实现。\n\n<!--more-->\n\n# 解决方案\n\n## 第一步，引入Jasypt依赖\n\n```xml\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>2.0.0</version>\n</dependency>\n```\n\n## 第二步，编写工具类\n\n**JasyptUtils：**\n\n```java\npackage com.keafmd.springdemo.utils;\n\nimport org.jasypt.encryption.pbe.PooledPBEStringEncryptor;\nimport org.jasypt.encryption.pbe.StandardPBEByteEncryptor;\nimport org.jasypt.encryption.pbe.config.SimpleStringPBEConfig;\n\n/**\n * Keafmd\n *\n * @ClassName: JasyptUtils\n * @Description:\n * @author: 牛哄哄的柯南\n * @date: 2022-04-25 11:18\n */\npublic class JasyptUtils {\n    /**\n     * Jasypt生成加密结果\n     *\n     * @param password 配置文件中设定的加密密码 jasypt.encryptor.password\n     * @param value    待加密值\n     * @return\n     */\n    public static String encryptPwd(String password, String value) {\n        PooledPBEStringEncryptor encryptOr = new PooledPBEStringEncryptor();\n        encryptOr.setConfig(cryptOr(password));\n        String result = encryptOr.encrypt(value);\n        return result;\n    }\n\n    /**\n     * 解密\n     *\n     * @param password 配置文件中设定的加密密码 jasypt.encryptor.password\n     * @param value    待解密密文\n     * @return\n     */\n    public static String decyptPwd(String password, String value) {\n        PooledPBEStringEncryptor encryptOr = new PooledPBEStringEncryptor();\n        encryptOr.setConfig(cryptOr(password));\n        String result = encryptOr.decrypt(value);\n        return result;\n    }\n\n    /**\n     * @param password salt\n     * @return\n     */\n    public static SimpleStringPBEConfig cryptOr(String password) {\n        SimpleStringPBEConfig config = new SimpleStringPBEConfig();\n        config.setPassword(password);\n        config.setAlgorithm(StandardPBEByteEncryptor.DEFAULT_ALGORITHM);\n        config.setKeyObtentionIterations(\"1000\");\n        config.setPoolSize(\"1\");\n        config.setProviderName(null);\n        config.setSaltGeneratorClassName(\"org.jasypt.salt.RandomSaltGenerator\");\n        config.setStringOutputType(\"base64\");\n        return config;\n    }\n\n    public static void main(String[] args) {\n        // 加密\n        // 盐值替换成自己熟悉的口令，此口令为解密密钥，需要妥善保管。\n        // 盐值也需要在第三步写入配置文件\n        System.out.println(encryptPwd(\"keafmd\", \"123456\"));\n    }\n}\n```\n\n## 第三步，修改配置文件\n\n- 把盐值写入配置文件\n- 把明文密码替换为工具类生成的密文，并用ENC(）包着\n\n\n\n**eg：**\n\n```yml\n# 连接数据源\nspring:\n  datasource:\n    username: root\n    password: ENC(aXcmM77CmYgj67mBxQgI2A==)\n    url: jdbc:mysql://XXXX:XX/tt?useUnicode=true&characterEncoding=UTF-8&useSSL=false\n    \njasypt:\n  encryptor:\n    password: keafmd\n```\n\n\n\n\n\n>**以上就是配置文件加密（Jasypt的简单使用）的全部内容**\n\n\n\n>**版权声明：keafmd**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.top/](https://keafmd.top/)**\n\n\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["Jasypt"],"categories":["Jasypt"]},{"title":"clion中cpp文件显示This file does not belong to any project ，code insight features might not work【解决方案】","url":"/2022/04/24/clion中cpp文件显示This file does not belong to any project ，code insight features might not work【解决方案】/","content":"\n\n\n# 问题\ncpp文件上方出现\n`This file does not belong to any project ，code insight features might not work properly`，并且main函数无法运行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1b60aaf08e6b4a988cca8a192be06a93.png)\n\n<!--more-->\n\n# 解决方案\n\n## 第一步：修改下CMakeLists.txt文件\n为了以后方便，我们先修改下CMakeLists.txt文件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/7530aa84b8764a65862ddfd13ba7c7b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54mb5ZOE5ZOE55qE5p-v5Y2X,size_20,color_FFFFFF,t_70,g_se,x_16)\n**CMakeLists.txt：**\n\n```cpp\n# 遍历项目根目录下所有的 .cpp 文件\nfile (GLOB_RECURSE files *.cpp)\nforeach (file ${files})\n    string(REGEX REPLACE \".+/(.+)\\\\..*\" \"\\\\1\" exe ${file})\n    add_executable (${exe} ${file})\n    message (\\ \\ \\ \\ --\\ src/${exe}.cpp\\ will\\ be\\ compiled\\ to\\ bin/${exe})\nendforeach ()\n```\n>**这样以后就不用再修改CMakeLists.txt这个文件了。**\n\n## 第二步：重新加载下项目\n![在这里插入图片描述](https://img-blog.csdnimg.cn/b5b821740a284b0ab0ec3836a1067291.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54mb5ZOE5ZOE55qE5p-v5Y2X,size_20,color_FFFFFF,t_70,g_se,x_16)\n>**加载完成后main函数就可以执行了，及时cpp文件上方还有那句话也不影响。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/933a865697274b85971e81f4a86c2a31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54mb5ZOE5ZOE55qE5p-v5Y2X,size_20,color_FFFFFF,t_70,g_se,x_16)\n>**以上就是clion中cpp文件显示This file does not belong to any project ，code insight features might not work【解决方案】的全部内容**\n\n>**版权声明：**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.top/](https://keafmd.top/)**\n\n\n\n**看完如果对你有帮助**\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["帮学妹解决问题"]},{"title":"买卖股票的最佳时机","url":"/2022/04/24/买卖股票的最佳时机/","content":"\n\n\n# 题目\n\n[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n难度 简单\n\n> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n\n<!-- more-->\n\n\n\n> 示例 1：\n>\n> 输入：[7,1,5,3,6,4]\n> 输出：5\n> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n>\n> \n>\n> 示例 2：\n>\n> 输入：prices = [7,6,4,3,1]\n> 输出：0\n> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n\n> 提示：1 <= prices.length <= 105\n> 0 <= prices[i] <= 104\n\n\n\n代码：\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        //dp dp[i]表示该天的最大利益\n        int[] dp = new int[prices.length];\n        //最大利益\n        int max = 0;\n        //从第二天开始，每天的最大利益取决于前一天的最大利益和当天的价格\n        for (int i = 1; i < prices.length; i++) {\n            //当前天的最大利益 = 前一天的最大利益 + 当天的价格 - 前一天的价格\n            //如果当天的利益小于0，则当天的利益为0\n            dp[i] = Math.max(dp[i-1] + prices[i] - prices[i-1],0);\n            //更新最大利益\n            max = Math.max(max,dp[i]);\n        }\n        //返回最大利益\n        return max;\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220424134137071](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204241341716.png)","tags":["每天进步一点点系列"]},{"title":"最长连续序列","url":"/2022/04/22/最长连续序列/","content":"\n\n\n# 题目\n\n题目：[最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)\n\n难度：中等\n\n> 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\n\n<!-- more -->\n\n> 示例 1：\n>\n> 输入：nums = [100,4,200,1,3,2]\n> 输出：4\n> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n>\n> 示例 2：\n>\n> 输入：nums = [0,3,7,2,5,8,4,6,0,1]\n> 输出：9\n>\n> 提示：0 <= nums.length <= 105\n> -109 <= nums[i] <= 109\n\n\n\n**题解：**先排下序，用个一维dp数组，dp[n]记录长度，最后求出最大的dp值就行了，数组长度为0的先处理下就行了，注意点就是返回值默认值为1，先给dp数组都初始化为1，因为最小的连续长度肯定是包含自身也就是1\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if(nums.length==0){\n            return 0;\n        }\n        //排序下\n        Arrays.sort(nums);\n        //max初始化为1，因为最小的连续序列长度为1，避免数组中只有一个元素的情况，也可以在上面写if提前过滤\n        int max = 1;\n        int[] dp = new int[nums.length];\n        //先填充个初始长度，包括本身，也就是1\n        Arrays.fill(dp,1);\n\n        for(int i=1;i<nums.length;i++){\n            //比前一个大，那么就是连续的\n            if(nums[i]==nums[i-1]+1){\n                dp[i] = dp[i-1] + 1;\n            }\n            //和前一个相等，连续长度保持就行\n            if(nums[i]==nums[i-1]){\n                dp[i] = dp[i-1];\n            }\n            max = Math.max(max,dp[i]);\n        }\n\n        return max;\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220422114734937](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204221147708.png)","tags":["每天进步一点点系列"]},{"title":"只出现一次的数字（水了个简单题）","url":"/2022/04/21/只出现一次的数字（水了个简单题）/","content":"\n\n\n# 题目\n\n题目：[只出现一次的数字](https://leetcode-cn.com/problems/single-number/)\n\n>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n>\n>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n<!-- more -->\n\n**示例 1:**\n\n```\n输入: [2,2,1]\n输出: 1\n```\n\n**示例 2:**\n\n```\n输入: [4,1,2,1,2]\n输出: 4\n```\n\n\n\n**题解：**\n\n> 本题可以直接使用异或(^,相同为0，不同为1)去解决，先说方案，异或数组中的所有数，最后剩下的就是只出现一次的数\n>\n> 分析：\n>\n> a^a = 0  0^b = b ,所以 a^a ^ b = b\n>\n> 拿个数举例子：\n>\n> 3 ^ 3 = 0011^0011 = 0000 = 0\n>\n> 0 ^ 2 = 0000^0010 = 0010 = 2\n>\n> 所以 3^3 ^2 = 2\n>\n> 最后所有出现偶数次的数异或后都成0了，0在和出现一次的（其实出现奇数次也是一样）异或，得到的就是我们要的那个数了\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        //用异或 ，因为 a^b^a = b \n        int res = 0;\n        for (int num : nums) {\n            //所以\n            res ^= num;\n        }\n        return res;\n    }\n}\n```\n\n","tags":["每天进步一点点系列"]},{"title":"名侦探柯南核心人物图","url":"/2022/04/19/名侦探柯南核心人物图/","content":"\n # 核心人物图\n\n![柯南](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%9F%AF%E5%8D%97.webp)\n\n\n\n<!-- more -->\n\n\n\n![新一](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%96%B0%E4%B8%80.webp)\n\n\n\n![小兰](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E5%B0%8F%E5%85%B0.webp)\n\n\n\n![毛利小五郎](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/%E6%AF%9B%E5%88%A9%E5%B0%8F%E4%BA%94%E9%83%8E.webp)\n\n![阿笠博士](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191545827.webp)\n\n![妃英理](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546437.webp)\n\n![工藤优作](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546944.webp)\n\n![工藤有希子](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546523.webp)\n\n![目暮警官](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546974.webp)\n\n![高木](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546545.webp)\n\n![佐藤](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546185.webp)\n\n![光彦](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546688.webp)\n\n![元太](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191546998.webp)\n\n![园子](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547553.webp)\n\n![步美](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547061.webp)\n\n![怪盗基德](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547557.webp)\n\n![和叶](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547245.webp)\n\n![平次](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/202204191547818.webp)\n\n\n\n\n\n来源\n\n百度百科：[柯南](https://baike.baidu.com/item/%E5%90%8D%E4%BE%A6%E6%8E%A2%E6%9F%AF%E5%8D%97/3469662?fromtitle=%E6%9F%AF%E5%8D%97&fromid=14081833)\n\n","tags":["柯南"]},{"title":"组合总和-Leetcode","url":"/2022/04/19/组合总和-Leetcode/","content":"\n# 每日题目\n\n题目：[组合总和](https://leetcode-cn.com/problems/combination-sum/)\n\n> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n>\n> candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n>\n> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n>\n\n<!-- more -->\n\n示例：\n\n> 示例 1：\n>\n> 输入：candidates = [2,3,6,7], target = 7\n> 输出：[[2,2,3],[7]]\n> 解释：\n> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。\n> 7 也是一个候选， 7 = 7 。\n> 仅有这两种组合。\n>\n> 示例 2：\n>\n> 输入: candidates = [2,3,5], target = 8\n> 输出: [[2,2,2,2],[2,3,3],[3,5]]\n>\n> 示例 3：\n>\n> 输入: candidates = [2], target = 1\n> 输出: []\n\n\n\n>\n> 提示：\n>\n> 1 <= candidates.length <= 30\n> 1 <= candidates[i] <= 200\n> candidate 中的每个元素都 互不相同\n> 1 <= target <= 500\n\n\n\n**代码：**\n\n```java\nclass Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res =  new ArrayList<>();\n        //如果数组为空，直接返回空结果\n        if(candidates==null||candidates.length==0){\n            return res;\n        }\n        //先排序\n        Arrays.sort(candidates);\n        //dfs\n        dfs(candidates,target,0,new ArrayList<>(),res);\n        return res;\n    }\n\n    public void dfs(int[] candidates,int target ,int start,List<Integer> list,List<List<Integer>> res){\n        //如果目标值为0，说明已经找到一个组合，添加到结果集中\n        if(target==0){\n            res.add(new ArrayList<>(list));\n            return;\n        }\n        //遍历数组\n        for (int i = start; i < candidates.length; i++) {\n            //如果当前值大于目标值，则不需要继续遍历\n            if(candidates[i]>target){\n                return;\n            }\n            list.add(candidates[i]);\n            //更新目标值和起始位置\n            dfs(candidates,target-candidates[i],i,list,res);\n            //回溯,删除当前值\n            list.remove(list.size()-1);\n        }\n\n\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220419095327903](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220419095327903.png)","tags":["每天进步一点点系列"]},{"title":"计算器","url":"/2022/04/18/计算器/","content":"\n# 每日题目\n\n题目：[计算器](https://leetcode-cn.com/problems/calculator-lcci/)\n\n> 给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。\n>\n> 表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。\n>\n\n<!-- more -->\n\n示例：\n\n> 示例 1:\n>\n> 输入: \"3+2*2\"\n> 输出: 7\n>\n> 示例 2:\n>\n> 输入: \" 3/2 \"\n> 输出: 1\n>\n> 示例 3:\n>\n> 输入: \" 3+5 / 2 \"\n> 输出: 5\n>\n> 说明：\n>\n> 你可以假设所给定的表达式都是有效的。\n> 请不要使用内置的库函数 eval。\n\n\n\n> 小坑，字符串里有空格，需要替换掉\n\n\n\n代码：\n\n```java\nclass Solution {\n    public int calculate(String s) {\n        s =s.replaceAll(\" \",\"\");\n        Deque<Integer> stack = new ArrayDeque<>();\n        //先把第一个加进去\n        char flag = '+';\n        //数字的初始值\n        int num = 0;\n        for(int i=0;i<s.length();i++){\n            //转换成数字\n            if(Character.isDigit(s.charAt(i))){\n                num = num*10+s.charAt(i)-'0';\n            }\n            //根据符号进行运行，就是*和/，优先级高，先把栈中的数字拿出来，运算后放进去\n            if(!Character.isDigit(s.charAt(i)) || i==s.length()-1){\n                if(flag=='+'){\n                    stack.push(num);\n                }else if(flag=='-'){\n                    stack.push(-num);\n                }else if(flag=='*'){\n                    stack.push(stack.pop()*num);\n                }else if(flag=='/'){\n                    stack.push(stack.pop()/num);\n                }\n                flag = s.charAt(i);\n                num =0;\n            }\n\n        }\n        //遍历栈，累加结果\n        int res =0;\n        while(!stack.isEmpty()){\n            res += stack.pop();\n        }\n\n        return res;\n\n\n    }\n}\n```\n\n","tags":["每天进步一点点系列"]},{"title":"使用LamdbaUpdateWrapper的setSql作用及风险","url":"/2022/04/12/使用LamdbaUpdateWrapper的setSql作用及风险/","content":"\n\n\n# 问题引入\n\n\n\n> 先思考下：我们要对数据库里面的某条数据进行更新，并且想要在某个字段原先的基础上修改，我们怎么办？\n\n\n\n<!-- more -->\n\n\n\n>正常的情况下，我们需要先查出来再更新，可就是想直接更新，那就需要去Mapper中写sql，就为了一个字段感觉费劲，在这种情况下使用LamdbaUpdateWrapper的setSql()方法即可。\n\n\n\n```java\n//把num字段加5\nLambdaUpdateWrapper<User> updateWrapper = Wrappers.<User>lambdaUpdate()\n\t.eq(User::getId, userId)\n\t.setSql(\"count = count + 5\");\n\nuserService.update(updateWrapper);\n```\n\n\n\nBUT，这样就会存在可能有风险，主要还是为了测试mybatis-plus，是否进行的防范，经过测试，并没有。\n\n比如就使用最常见的 sleep()，把这部分加到sql段中 `+ sleep(5)`\n\n```java\nLambdaUpdateWrapper<User> updateWrapper = Wrappers.<User>lambdaUpdate()\n                .eq(User::getId, userId)\n                .setSql(\"count = count + 5 + sleep(5)\");\n```\n\n\n\n![image-20220418154212043](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220418154212043.png)\n\n\n\n不过话说回来，这也就是开发人员能接触到的，只是证明mybatis-plus并没有对setSql()进行过滤，是采取直接拼上去的方式。\n\n\n\n# 每日单词\n\n![image-20220418154234138](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220418154234138.png)","tags":["java"]},{"title":"最小差值（附加单词积累）","url":"/2022/04/12/最小差值（附加单词积累）/","content":"\n\n\n# 每日题目\n\n题目：[最小差值 I](https://leetcode-cn.com/problems/smallest-range-i/)\n\n> 给你一个整数数组 nums，和一个整数 k 。\n>\n> 在一个操作中，您可以选择 0 <= i < nums 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。\n>\n> nums 的 分数 是 nums 中最大和最小元素的差值。 \n>\n> 在对nums中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。\n\n<!-- more -->\n\n示例：\n\n> 示例 1：\n>\n> 输入：nums = [1], k = 0\n> 输出：0\n> 解释：分数是 max(nums) - min(nums) = 1 - 1 = 0。\n> 示例 2：\n>\n> 输入：nums = [0,10], k = 2\n> 输出：6\n> 解释：将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n> 示例 3：\n>\n> 输入：nums = [1,3,6], k = 3\n> 输出：0\n> 解释：将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n\n\n提示：\n\n> 1 <= nums.length <= 104\n> 0 <= nums[i] <= 104\n> 0 <= k <= 104\n\n代码：\n\n```java\nclass Solution {\n    public int smallestRangeI(int[] nums, int k) {\n        int res =0;\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        //取最大最小值\n        for (int num : nums) {\n            max = Math.max(max, num);\n            min = Math.min(min, num);\n        }\n        //这样取最大最小值速度慢\n//        Arrays.sort(nums);\n//        min = nums[0];\n//        max = nums[nums.length - 1];\n        //最大值减k，最小值加k，然后算差值res\n        res = max - min - 2 * k;\n        //因为k可变，如果res<0,就证明可以把最大最小值变成一样，so，res = 0\n        if(res < 0) {\n            res = 0;\n        }\n\n        return res;\n    }\n}\n```\n\n\n\n# 每日单词\n\n![image-20220412120606361](https://cdn.jsdelivr.net/gh/Keafmd/drawing-bed/img/image-20220412120606361.png)","tags":["每天进步一点点系列"]},{"title":"DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】","url":"/2022/03/18/DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】/","content":"\n\n\n# DataGrip连接人大金仓数据库（kingbase）详细教程【超详细】\n\n\n\n# 第一步：下载DataGrip\n\n**官网地址：[戳这里](https://www.jetbrains.com/zh-cn/datagrip/download/#section=windows)**\n\n![image-20210913111047913](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021459816.png)\n\n\n\n<!-- more -->\n\n\n\n# 第二步：添加人大金仓的数据库引擎\n\n> **其实就是选择我们本地仓库引入的jar包**\n\n\n\n**如下图：**\n\n![image-20210913111417486](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021459327.png)\n\n> **选择Driver Files，也就是我们本地仓库中kingbase8的jar包**\n\n\n\n![image-20210913111636394](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500539.png)\n\n> **从本地仓库中找到**\n\n\n\n![image-20210913111654473](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500709.png)\n\n\n\n> **切换Class**\n\n\n\n![image-20210913111758561](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500688.png)\n\n> **完成后如下图：**\n\n\n\n![image-20210913111507062](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500158.png)\n\n\n\n> **点击Apply保存引擎**\n\n\n\n![image-20210913111854079](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500077.png)\n\n# 第三步：输入账号密码连接\n\n![image-20210913112022474](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500183.png)\n\n\n\n> **先测试连接一下**\n\n![image-20210913112050134](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500322.png)\n\n> **没有问题就点击OK**\n\n\n\n# 第四步：查看数据库\n\n\n\n> **我们需要勾选下All database，不然看不到表数据**\n\n\n\n![image-20210913112202575](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500556.png)\n\n\n\n> **这样就OK了**\n\n![image-20210913112435055](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021500427.png)\n\n# 关于连接其它数据库\n\n> **连接其他数据库的时候，自定义性没有那么强，可以从支持的数据库中选择，上面连接kingbase数据库自定义性较强，使用DataGrip比较方便，对于MySQL这些比较常用的，使用我们比较熟悉的SQLYog、Naviate即可。**\n\n\n\n![image-20210913112521317](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021501149.png)\n\n![image-20210913112949157](https://raw.githubusercontent.com/Keafmd/drawing-bed/main/img/202204021501799.png)","tags":["kingbase"]},{"title":"mysql和oorcale日期区间查询【含左右区间问题】","url":"/2021/12/13/mysql和oorcale日期区间查询【含左右区间问题】/","content":"\n# mysql和oorcale日期区间查询【含左右区间问题】\n\n> **直接看样例↓**\n\n\n**mysql：**\n\n```sql\n\n-- 查询区间[2021-12-01,2021-12-03)\nSELECT * FROM b WHERE b.trigger_time >= '2021-12-01' \nAND b.trigger_time <= '2021-12-03'\n\n-- 查询区间[2021-12-01,2021-12-03]\nSELECT * FROM b WHERE to_days( b.trigger_time ) >= to_days( '2021-12-01' ) \nAND to_days( b.trigger_time ) <= to_days( '2021-12-03' )\n\t\n```\n\n<!-- more -->\n\n**orcale：**\n\n```sql\n\n-- 查询区间[2021-12-01,2021-12-03)\nSELECT * FROM b WHERE b.trigger_time >= to_date( '2021-12-01', 'yyyy-MM-dd' ) \nAND b.trigger_time <= to_date( '2021-12-03', 'yyyy-MM-dd' )\n\n\n-- 查询区间[2021-12-01,2021-12-03]\nSELECT * FROM b WHERE to_char( b.trigger_time, 'yyyy-MM-dd' ) >= '2021-12-01' \nAND to_char( b.trigger_time, 'yyyy-MM-dd' ) <= '2021-12-03'\n\n```\n\n>**以上就是mysql和oorcale日期区间查询【含左右区间问题】的全部内容**\n\n>**版权声明：**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.blog.csdn.net/](https://keafmd.blog.csdn.net/)**\n\n\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["mysql"]},{"title":"规范【锦上添花系列】","url":"/2021/10/25/规范【锦上添花系列】/","content":"\n\n\n>**我们提交代码时，有时可能没有什么格式，就简单记录下这次提交了哪部分代码，但是当我们看gitee和github上的提交时就会发现，在提交信息前会有一些单词，那就是用来标识这次提交代码的类别的。**\n\n**规范的好处：**\n- **首先可读性强，不比深看代码，即可知道本次commit的作用**\n- **便于根据项目开发历史**\n- **提高项目整体质量，提高个人专业性**\n- **为Code Reviewing做准备**\n- ...\n\n<!-- more -->\n\n**规范有很多种，本文介绍目前使用最广泛的Angular 规范**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/0210eac7b05f4bc38b0a04fcd36c9a96.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54mb5ZOE5ZOE55qE5p-v5Y2X,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n>**关于commit的类别，Angular 规范提到了七种标识：**\n- **feat：最常用的，开发新功能**\n- **fix：也常用，修复bug**\n- **docs：文档**\n- **style：常用，格式修改（不改变代码运行）**\n- **refactor：重构，改变代码结构，不是新功能也不是修复bug**\n- **test：测试**\n- **chore：维护，一些其它修改**\n\n\n>**版权声明：**\n>**原创博主：牛哄哄的柯南**\n>**博主原文链接：[https://keafmd.blog.csdn.net/](https://keafmd.blog.csdn.net/)**\n\n\n\n**看完如果对你有帮助，感谢点击下面的==一键三连==支持！\n[哈哈][抱拳]**\n![请添加图片描述](https://img-blog.csdnimg.cn/e76df83ccd6d4e139968fbb68f7b1f99.png)![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["git"]},{"title":"浅显理解Java泛型的super和extends","url":"/2021/08/06/浅显理解Java泛型的super和extends/","content":"\n\n\n# 浅显理解Java泛型的super和extends\n\n# 目录\n\n## 概念简单理解\n\n- List<? extends T>表示该集合中存在的都是类型T的子类，包括T自己\n\n- List<? super T>表示该集合中存的都是类型T的父类，包括T自己\n\n<!-- more -->\n\n## 代码样例解读\n\n==**父子类代码：**==\n\n```java\n/**\n * 生物\n */\nstatic class Biological{\n}\n\n/**\n * 动物\n */\nstatic class Animal extends Biological{\n}\n\n/**\n * 植物\n */\nstatic class Plant extends Biological{\n}\n\n\nstatic class Dog extends Animal{\n}\n\nstatic class Cat extends Animal{\n}\n\nstatic class Flower extends Plant{\n}\n\nstatic class Tree extends Plant{\n}\n```\n\n\n\n**==关系图：==**\n\n![fanxing](https://gitee.com/Keafmd/drawing-bed/raw/master/img/20210804161818.png)\n\n\n\n**==测试代码：==**\n\n```java\npublic static void main(String[] args) {\n\n    List<? super Animal> listA = new ArrayList<>();\n    List<? extends Plant> listB = new ArrayList<>();\n\n    //listA.add(new Biological());  \n    listA.add(new Animal());\n    listA.add(new Dog());\n    //listA.add(new Flower());\n    Object object = listA.get(0);\n\n    //listB.add(new Plant());\n    //listB.add(new Flower());\n    listB.add(null);\n    Plant plant = listB.get(0);\n\n}\n```\n\n## 关于List<? super T>\n\n### add方面\n\n```java\nList<? super Animal> listA = new ArrayList<>();\n```\n\n```\nlistA.add(new Biological());  \n```\n\n执行上面这行代码是不允许的，因为listA的集合类型是Animal或者更高的父类，想一下如果代表的类型是Animal，那怎么允许add它的父类Biological呢？当然不允许了。\n\n```java\nlistA.add(new Animal());\nlistA.add(new Dog());\n```\n\n执行上面这两句就是可以正常执行的，因为无论是Animal还是Animal的子类Dog，都是可以存到集合类型是Animal或者更高的父类的集合中的。有点拗口，不过就是这个意思。\n\n```java\nlistA.add(new Flower());\n```\n\n添加Flower当然是不可以的，因为它不是Animal的子类。\n\n### 返回值方面\n\n```java\nObject object = listA.get(0);\n```\n\n因为listA的集合类型是Animal或者更高的父类，所以不清楚到底会是哪个类，但是我们都应该清楚所有类的父类都是Object，所以返回值是Object类型的。\n\n## 关于List<? extendsT>\n\n### add方面\n\n```java\nList<? extends Plant> listB = new ArrayList<>();\n```\n\n```java\nlistB.add(new Plant());\n```\n\n执行上面的代码是不允许的，因为listB的集合类型是Plant或Plant的子类，想一下如果代表的类型是Plant的子类Tree，那么怎么可能可以add它的父类Plant呢？所以跟上面的那个理解差不多，就是反过来理解。看图可以更加清晰。\n\n```java\nlistB.add(new Flower());\n```\n\n这个同理，如何代表的类型是Flower的子类Rose(玫瑰花)，这样当然不可以add它的父类Flower了。\n\n```java\nlistB.add(null);\n```\n\n特殊情况就是这个，可以add null，但是也没意义啊。\n\n### 返回值方面\n\n```java\nPlant plant = listB.get(0);\n```\n\n因为listB的集合类型是Plant或者它的子类，所以不清楚到底会是哪个类，但是我们可以知道，最高的类型就是Plant了，所以返回值就是Plant类型的。\n\n## 总结\n\n- List<? super T>表示该集合中存的都是类型T的父类，包括T自己\n\n  - add：不能add任何对象（特例：可以添加null）\n\n- get：get返回的对象类型为T\n\n- List<? extends T>表示该集合中存在的都是类型T的子类，包括T自己\n\n  - add：只能添加T及T的子类\n\n  - get：get返回的对象类型为Object\n\n    \n\n  ","tags":["java"]},{"title":"日常Java练习题（每天进步一点点系列）","url":"/2021/05/13/日常Java练习题（每天进步一点点系列）/","content":"\n\n\n**==提示==：好多小伙伴反映，直接看到答案不太好，那我把答案的颜色设置为透明，答案位置还是在题目后面，需要鼠标选中才能看见（操作如下图），同时为了手机端的小伙伴，我还会把所有答案放到文章最下面，希望给每天进步一点点的小伙伴更好的体验，==末尾还有福利==。**\n\n\n\n<!-- more -->\n\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210513143525820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n**==1==、以下程序段的输出结果为：\npublic class EqualsMethod\n{\n    public static void main(String[] args)\n    {\n        Integer n1 = new Integer(47);\n        Integer n2 = new Integer(47);\n        System.out.print(n1 == n2);\n        System.out.print(\",\");\n        System.out.println(n1 != n2);\n    }\n}\n<font color = white>正确答案: B   你的答案: B (正确)</font>\nfalse，false\nfalse，true\ntrue，false\ntrue，true**\n\n>**题解：\n>首先 我们要知道 `==` 这个比较符号\n>`==`可用于基本类型和引用类型：当用于基本类型时候，是比较值是否相同；当用于引用类型的时候，是比较对象是否相同。\n>\"==\"和 \"!=\"比较的是地址 指第一个new()出来的地址\n>因为两次new() 出的内存也不同\n>所以System.out.print(n1 == n2);返回 false\n>所以System.out.println(n1 != n2);就返回true\n>所以选B**\n\n**==2==、在java7中，下列不能做switch()的参数类型是？\n<font color = white>正确答案: D   你的答案: D (正确)</font>\nint型\n枚举类型\n字符串\n浮点型**\n\n>**题解：\n>switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。**\n\n**==3==、以下代码的输出结果是？\npublic class B\n{\n    public static B t1 = new B();\n    public static B t2 = new B();\n    {\n        System.out.println(\"构造块\");\n    }\n    static\n    {\n        System.out.println(\"静态块\");\n    }\n    public static void main(String[] args)\n    {\n        B t = new B();\n    }\n}\n<font color = white>正确答案: C   你的答案: C (正确)</font>\n静态块 构造块 构造块 构造块\n构造块 静态块 构造块 构造块\n构造块 构造块 静态块 构造块\n构造块 构造块 构造块 静态块**\n\n>**题解：\n>开始时JVM加载B.class，对所有的静态成员进行声明，t1 t2被初始化为默认值，为null，又因为t1 t2需要被显式初始化，所以对t1进行显式初始化，初始化代码块→构造函数（没有就是调用默认的构造函数），咦！静态代码块咋不初始化？因为在开始时已经对static部分进行了初始化，虽然只对static变量进行了初始化，但在初始化t1时也不会再执行static块了，因为JVM认为这是第二次加载类B了，所以static会在t1初始化时被忽略掉，所以直接初始化非static部分，也就是构造块部分（输出''构造块''）接着构造函数（无输出）。接着对t2进行初始化过程同t1相同（输出'构造块'），此时就对所有的static变量都完成了初始化，接着就执行static块部分（输出'静态块'），接着执行，main方法，同样也，new了对象，调用构造函数输出（'构造块'），所以选C**\n\n**==4==、What results from the following code fragment?\n（翻译：下面的代码片段产生了什么结果？）\nint i = 5;\nint j = 10;\nSystem.out.println(i + ~j);\n<font color = white>正确答案: C   你的答案: C (正确)</font>\nCompilation error because”~”doesn’t operate on integers\n-5\n-6\n15**\n\n>**题解：\n>公式-n=~n+1可推出~n=-n-1，所以~10=-11再加5结果为-6**\n\n**==5==、对于构造方法，下列叙述正确的是（ ）。\n<font color = white>正确答案: A C D   你的答案: A C D(正确)</font>\n构造方法的优先级一般比代码块低。\n构造方法的返回类型只能是void型。\n构造方法的主要作用是完成对类的对象的初始化工作。\n一般在创建新对象时，系统会自动调用构造方法。**\n\n>**题解：\n>A：静态成员变量或静态代码块>main方法>非静态成员变量或非静态代码块>构造方法\n>B：think in java中提到构造器本身并没有任何返回值。\n>C: 构造方法的主要作用是完成对类的对象的初始化工作。\n>D: 一般在创建(new)新对象时，系统会自动调用构造方法。**\n\n**==6==、JDK1.7版本之前，接口和抽象类描述正确的有（ ）\n<font color = white>正确答案: B C   你的答案: B C (正确)</font>\n抽象类没有构造函数。\n接口没有构造函数。\n抽象类不允许多继承。\n接口中的方法可以有方法体。**\n\n>**题解：\n>A.抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已\n>B.在接口中 不可以有构造方法,在接口里写入构造方法时，编译器提示：Interfaces cannot have constructors。\n>C.Java不允许类多重继承\n>D.jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体**\n\n**==7==、以下关于JAVA语言异常处理描述正确的有？\n<font color = white>正确答案: C D   你的答案: C D (正确)</font>\nthrow关键字可以在方法上声明该方法要抛出的异常。\nthrows用于抛出异常对象。\ntry是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。\nfinally语句块是不管有没有出现异常都要执行的内容。\n在try块中不可以抛出异常**\n\n>**题解：\n>Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。\n>throw用于抛出异常。\n>throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。\n>try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。\n>cacth用于捕获从try中抛出的异常并作出处理。\n>finally语句块是不管有没有出现异常都要执行的内容。**\n\n**==8==、下面程序输出结果为（）：\npublic class Demo{\npublic static void main (String [] args) {\nString lx = “LeXin”;\nString nb = lx;\nlx = “Fenqile”;\nSystem.out.println(nb);\n}\n}\n<font color = white>正确答案: B C   你的答案: B C (正确)</font>\n程序异常，编译不通过\n程序编写正常，可正常运行\n程序输出值为“LeXin”\n程序输出值为“Fenqile”**\n\n>**题解：\n>很显然是把“LeXin”的值赋给了nb**\n\n**==9==、java中关于继承的描述正确的是（）\n<font color = white>正确答案: A C D   你的答案: A C D (正确)</font>\n一个子类只能继承一个父类\n子类可以继承父类的构造方法\n继承具有传递性\n父类一般具有通用性，子类更具体**\n\n>**题解：\n>子类不可以继承父类的构造方法，只可以调用父类的构造方法。子类中所有的构造函数都会默认访问父类中的空参数构造函数，这是因为子类的构造函数内第一行都有默认的super（）语句。**\n\n**==10==、What is Static Method in Java（）\n<font color = white>正确答案: A B C   你的答案: A B C (正确)</font>\nIt is a method which belongs to the class and not to the object(instance)\nA static method can access only static data. It can not access non-static data (instance variables)\nA static method can call only other static methods and can not call a non-static method from it.\nA static method can not be accessed directly by the class name and doesn’t need any object**\n\n>**题解：\n>A：静态方法是一个属于类而不属于对象(实例)的方法。（√）\n>B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）\n>C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）\n>D：静态方法不能通过类名直接访问，也不需要任何对象。（×） 静态方法可以直接用类名访问。**\n\n\n\n**<font color =#40b1f7>最近很多小伙伴希望我推荐个比较详细的Java零基础教程，下面这个是我看过的觉得挺不错的，值得收藏系列。\n链接：[点这里也可以](https://www.bilibili.com/video/BV1Rx411876f)\nhttps://www.bilibili.com/video/BV1Rx411876f</font>**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210513145838608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**答案汇总：\n1、正确答案: B\n2、正确答案: D\n3、正确答案: C\n4、正确答案: C\n5、正确答案:  A C D\n6、正确答案: B C\n7、正确答案: C D\n8、正确答案: B C\n9、正确答案: A C D\n10、正确答案:A B C** \n\n\n\n>**以上部分题解来自牛客评论区，感谢评论区大佬的解释。**\n\n>**每天进步一点点！\n>不进则退！**\n\n**看完如果对你有帮助，感谢点赞支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["每天进步一点点系列"]},{"title":"SpringBoot集成使用jsp（超详细）","url":"/2021/04/06/SpringBoot集成使用jsp（超详细）/","content":"\n\n\n# 添加依赖\n>**SpringBoot-starter-web内嵌的Tomcat无法解析jsp（Thymeleaf），需要额外添加类库：Jasper**\n\n```xml\n<!-- 解析jsp类库  -->\n<dependency>\n    <groupId>org.apache.tomcat.embed</groupId>\n    <artifactId>tomcat-embed-jasper</artifactId>\n</dependency>\n```\n\n<!-- more -->\n\n# 添加上下文目录\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154650281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154835620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402154918102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155329817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**中途会提示是否生成文件夹，确认下就行了，最后会多个webapp文件夹，效果如下↓**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155525552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 指定SpringBoot的启动目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155626295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**添加上`$ContentRoot$`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402155706249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# 设置application.properties\n\n```java\n#页面默认前缀目录 默认在webapp下有别的文件夹可以，以文件夹/往下加\nspring.mvc.view.prefix=/\n#页面默认后缀目录\nspring.mvc.view.suffix=.jsp\n```\n\n# 测试是否可行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021040216000554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**ViewController：**==\n```java\npackage com.keafmd.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n\n/**\n * Keafmd ！\n *\n * @ClassName: ViewController\n * @Description:\n * @author: 牛哄哄的柯南\n * @Date: 2021-04-02 14:47\n * @Blog: https://keafmd.blog.csdn.net/\n */\n@Controller\npublic class ViewController {\n\n    @GetMapping(\"getname\")\n    public String getName(Model model){\n        model.addAttribute(\"name\",\"keafmd\");\n        return \"name\";\n    }\n    @GetMapping(\"getage\")\n    public String getAge(Model model){\n        model.addAttribute(\"age\",18);\n        return \"age\";\n    }\n}\n```\n**在webapp下创建name.jsp和age.jsp**\n\n==**name.jsp：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: lenovo\n  Date: 2021/4/2\n  Time: 14:31\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<h1>name</h1>\n${name}\n\n</body>\n</html>\n```\n\n==**age.jsp：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: lenovo\n  Date: 2021/4/2\n  Time: 15:29\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<h1>age</h1>\n${age}\n\n</body>\n</html>\n```\n\n**----------启动程序----------**\n\n**访问：`http://127.0.0.1:8080/getage`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402160347237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**访问：`http://127.0.0.1:8080/getname`**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210402160420110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**搞定！**\n\n>**以上就是SpringBoot集成使用jsp（超详细）的全部内容。**\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n![](https://gitee.com/Keafmd/drawing-bed/raw/master/img/timg7L0CY2U1.jpg)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["SpringBoot"]},{"title":"Mybatis的动态SQL语句","url":"/2021/02/13/Mybatis的动态SQL语句/","content":"\n# 项目目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021021221312397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n\n<!-- more -->\n\n\n\n# 动态 SQL 之if标签\n\n## 持久层 Dao 接口\n\n```java\n/**\n * 根据传入的参数条件\n * @param user 查询的条件，有可能有用户名 ，性别，或都没有\n * @return\n */\nList<User> finduserCondition(User user);\n```\n## 持久层 Dao 映射配置\n\n```xml\n<!--根据条件查询-->\n<select id=\"finduserCondition\" resultMap=\"userMap\" parameterType=\"user\">\n    select * from user where 1=1\n    <if test=\"userName != null\">\n        and username = #{userName}\n    </if>\n    <if test=\"userSex != null\">\n        and sex = #{userSex}\n    </if>\n</select>\n```\n## 测试代码\n\n```java\n/**\n * 根据条件查询 if标签\n * @throws Exception\n */\n@Test\npublic void testfinduserCondition() throws Exception {\n\n    User u = new User();\n    u.setUserName(\"老王\");\n    u.setUserSex(\"男\");\n    //5.使用代理对象执行方法\n    List<User> users = userDao.finduserCondition(u);\n    for (User user : users) {\n        System.out.println(user);\n    }\n\n}\n```\n==**测试结果：**==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210212211927937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 动态 SQL 之where标签\n>**为了简化上面 where 1=1 的条件拼装，我们可以采用`<where>`标签来简化开发。**\n\n## 持久层 Dao 映射配置\n```xml\n<select id=\"finduserCondition\" resultMap=\"userMap\" parameterType=\"user\">\n    select * from user\n    <where>\n        <if test=\"userName != null\">\n            and username = #{userName}\n        </if>\n        <if test=\"userSex != null\">\n            and sex = #{userSex}\n        </if>\n    </where>\n</select>\n```\n>**效果和上面的if标签一样**\n\n# 动态 SQL 之foreach标签\n## 需求\n>**传入多个 id 查询用户信息，用下边两个 sql 实现：\n>SELECT * FROM USERS WHERE username LIKE '%王%' AND (id =10 OR id =19 OR id=36)\n>SELECT * FROM USERS WHERE username LIKE '%王%' AND id IN (10,19,36)**\n>**这样我们在进行范围查询时，就要将一个集合中的值，作为参数动态添加进来。**\n\n## 在 QueryVo 中加入一个 List 集合用于封装参数\n==**QueryVo：**==\n```java\npackage com.keafmd.domain;\n\nimport java.util.List;\n\n/**\n * Keafmd\n *\n * @ClassName: QueryVo\n * @Description:\n * @author: 牛哄哄的柯南\n * @date: 2021-02-08 21:08\n */\npublic class QueryVo {\n    private  User user;\n    private List<Integer> ids;\n\n    public List<Integer> getIds() {\n        return ids;\n    }\n\n    public void setIds(List<Integer> ids) {\n        this.ids = ids;\n    }\n\n    public User getUser() {\n        return user;\n    }\n\n    public void setUser(User user) {\n        this.user = user;\n    }\n}\n```\n## 持久层 Dao 接口\n```java\n/**\n * 根据QueryVo中提供的id集合查询\n * @param vo\n * @return\n */\nList<User> findUserInIds(QueryVo vo);\n```\n\n## 持久层 Dao 映射配置\n\n```xml\n<!--根据QueryVo中的id集合实现查询查询用户列表-->\n<select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\">\n    <include refid=\"defaultUser\"></include>\n    <where>\n        <if test=\"ids!=null and ids.size()>0\">\n            <foreach collection=\"ids\" open = \"and id in (\" close=\")\" item=\"uid\" separator=\",\">\n                #{uid}\n            </foreach>\n\n        </if>\n    </where>\n</select>\n```\n## 测试代码\n\n```java\n@Test\npublic void testfindUserInIds() throws Exception {\n\n    QueryVo vo = new QueryVo();\n    List<Integer> list = new ArrayList<Integer>();\n    list.add(41);\n    list.add(42);\n    list.add(50);\n    vo.setIds(list);\n\n    //5.使用代理对象执行方法\n    List<User> users = userDao.findUserInIds(vo);\n    for (User user : users) {\n        System.out.println(user);\n    }\n\n}\n```\n==**测试结果：**==\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021021221354223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# Mybatis中简化编写的 SQL 片段\n>**Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的。**\n>**这样可以简化我们每次都需要在sql语句中写的`select * from user`。**\n\n## 定义代码片段\n\n```xml\n<!--了解的内容，抽取重复的sql语句-->\n<sql id=\"defaultUser\">\n    select * from user\n</sql>\n```\n>**==注意细节==：在抽取重复的sql语句尽量不要写分号`;`,因为可能还会和后面的sql语句进行拼接，有分号就会导致报错。**\n\n\n## 引用代码片段\n\n```xml\n<!--配置查询所有-->\n<select id=\"findAll\" resultMap=\"userMap\">\n    <include refid=\"defaultUser\"></include>\n</select>\n\n<!--根据QueryVo中的id集合实现查询查询用户列表-->\n<select id=\"findUserInIds\" resultMap=\"userMap\" parameterType=\"queryvo\">\n     <include refid=\"defaultUser\"></include>\n     <where>\n         <if test=\"ids!=null and ids.size()>0\">\n             <foreach collection=\"ids\" open = \"and id in (\" close=\")\" item=\"uid\" separator=\",\">\n                 #{uid}\n             </foreach>\n\n         </if>\n     </where>\n</select>\n```\n\n>**以上就是Mybatis的动态SQL语句的全部内容。**\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["Mybatis"]},{"title":"解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题","url":"/2021/01/30/解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题/","content":"\n### 有些时候我们会看到错误日志，显示没有权限访问tomcat下的某某目录，或者用tomcat时报出了一些错误，极有可能和我们的tomcat文件夹存在访问权限的问题有关！我们试一下在tomcat下的某些目录，特别是在temp文件夹下创建文件，看是否需要管理员权限，有时我们把tomcat装到了系统盘，就会显示需要管理员权限才可以创建文件，这样会导致很多情况下提示在tomcat的目录下存在访问权限的问题。\n\n\n\n# <font color=red>解决办法：</font>\n\n<!-- more -->\n\n **进到tomcat所在的文件夹，我的是：D:\\Program Files\\apache\\apache-tomcat-8.5.60（我的D盘是当初C盘分出来的，所以存在权限问题）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225015329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n **在apache目录下：==鼠标右键-->属性-->安全-->编辑==把==ALL APPLICATION PACKAGES==和==User(xxxx\\Users)==下的访问权限==全部允许==就可以了，基本上就是==完全控制和修改==没有打上勾，勾上就可以了。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225818409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210130225745956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n **这样基本就可以解决很多时候由于访问tomcat而导致的权限问题了。**\n\n>**以上就是解决访问tomcat下文件夹（如temp）显示有权限【在tomcat目录下创建文件需要管理员权限】的问题的全部内容。**\n\n**看完如果对你有帮助，感谢支持！**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115230629703.gif#pic_center)\n\n**加油！**\n\n**共同努力！**\n\n**Keafmd**","tags":["tomcat"]},{"title":"Spring入门案例【spring框架创建对象】（超详细）","url":"/2021/01/26/Spring入门案例【spring框架创建对象】（超详细）/","content":"\n# Spring框架概述\n**（1）Spring是轻量级的开源的JavaEE框架。\n（2）Spring可以解决企业应用开发的复杂性。\n（3）Spring框架主要由七部分组成，分别是 Spring Core、 Spring AOP、 Spring ORM、 Spring DAO、Spring Context、 Spring Web和 Spring Web MVC。\n（4）<font color=red>Spring有两个核心部分：IOC和AOP\n&nbsp; &nbsp;&nbsp;1、IOC：控制反转，把创建对象的过程交给Spring进行管理。\n  &nbsp;&nbsp; &nbsp;2、AOP：面向切面，不修改源代码进行功能增强。</font>**\n\n<!-- more -->\n\n# Spring框架特点\n**（1）方便解耦，简化开发。\n（2）AOP编程支持。\n（3）方便程序测试。\n（4）方便和其他框架进行整合。\n（5）方便进行事务操作。\n（6）降低API开发难度。**\n\n# 准备过程\n**本文是按照spring-5.2.6进行演示。**\n## 下载 spring-5.2.6.RELEASE-dist.zip\n**下载地址：[ spring-5.2.6](https://repo.spring.io/release/org/springframework/spring/5.2.6.RELEASE/)**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114231911473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n## 下载 commons-logging-1.2-bin.zip\n**下载地址：[commons-logging-1.2](http://commons.apache.org/proper/commons-logging/download_logging.cgi)**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232119862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n## 把两个zip解压挑选核心基础的五个jar包放到新创建的文件夹中\n**如下图所示即可，创建个新的文件夹core用于存放核心基础的五个jar包。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232403922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**从 spring和commons中复制出来这五个。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232708594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**Spring中四个jar包的路径：spring-framework-5.2.6.RELEASE\\libs下**\n**从这里面复制出来放到core里面**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114232921741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**commons中一个jar包的路径：commons-logging-1.2下**\n**把这个复制出来放到core里面**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233108249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**操作完成以上步骤后就可以进入idea操作了**\n\n# 创建一个新的Java项目\n**New Project**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233421875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**勾选上继续下一步**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233511869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**写个项目名，Base package根据自己想命名的改，也可以不改，Finish。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114233643327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n# 创建lib文件夹，导入jar包\n**在这个位置创建好lib文件夹后，直接从刚才准备好的core文件夹中把那五个核心jar包复制粘贴过来即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234353903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n# 添加依赖\n**1、如图所示点击打开。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234639631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**2、继续按图操作**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234747976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**3、找到lib把那五个jar包全部选中点击OK**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234915642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n**4、这样就导入进来了然后点击**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114235234132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n# 创建个User类\n**有一些是我写的其它的，忽略即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210114234156235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**User类代码：**==\n\n```java\npackage com.Keafmd.spring5;\n\n/**\n * Keafmd\n *\n * @ClassName: User\n * @Description: User类\n * @author: 牛哄哄的柯南\n * @date: 2021-01-14 19:58\n */\npublic class User {\n\n\t//只写个方法就行了\n    public  void add(){\n        System.out.println(\"add....\");\n    }\n}\n```\n# 在src下创建bean1.xml\n**我的写的有些其它内容，具体代码看下面的代码即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021011423552534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n==**bean1.xml：**==\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- 添加这一行就可以了,配置User对象的创建-->\n    <bean id=\"user\" class=\"com.Keafmd.spring5.User\"></bean>\n\n</beans>\n```\n\n# 创建测试样例\n**在如图位置创建即可。**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115000039864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n==**测试代码：**==\n\n```java\npackage com.Keafmd.spring5.testdemo;\n\nimport com.Keafmd.spring5.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * Keafmd\n *\n * @ClassName: TestSpring5\n * @Description:\n * @author: 牛哄哄的柯南\n * @date: 2021-01-14 20:06\n */\npublic class TestSpring5 {\n\t//写完 @Test有红色提醒是因为没导入，直接导入就可以了。\n    @Test\n    public void testAdd(){\n        //1、载Spring的配置文件\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean1.xml\");\n\n        //2、获取配置文件中创建的对象  默认是执行无参的构造方法创建\n        User user =applicationContext.getBean(\"user\", User.class);\n\n        System.out.println(user);\n        user.add();\n\n    }\n}\n```\n\n==**测试结果：**==\n```java\ncom.Keafmd.spring5.User@150c158\nadd....\n\nProcess finished with exit code 0\n```\n**运行测试代码，输出user对象的地址和add方法的输出语句就证明完成了入门案例。Spring的核心思想是IOC，即所有对象的创建都是通过Spring，而不需要自己手动生成，这样我们就完成了用spring框架创建对象的入门案例。**\n\n**写作不易，看完如果对你有帮助，感谢点赞支持！\n如果你是电脑端，看到右下角的 “==一键三连==” 了吗，没错点它[哈哈]**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201023201048810.gif#pic_center)\n**加油！**\n\n**共同努力！**\n\n**Keafmd**"},{"title":"SpringMVC中常用注解（案例讲解）","url":"/2021/01/25/SpringMVC中常用注解（案例讲解）/","content":"\n### SpringMVC中常用注解\n\n<!-- more -->\n\n# RequestParam\n\n<font size =5>**说明**</font>\n>**==作用：==\n>把请求中指定名称的参数给控制器中的形参赋值。\n>==属性：==\n>value：请求参数中的名称。\n>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<%--\n  Created by IntelliJ IDEA.\n  User: Keafmd\n  Date: 2021/1/25\n  Time: 10:48\n  To change this template use File | Settings | File Templates.\n--%>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>常用注解</title>\n</head>\n<body>\n\n    <!-- requestParams 注解的使用 -->\n    <a href=\"anno/testRequestParam?name=keafmd\">RequestParam</a><br/>\n\n</body>\n</html>\n```\n==**控制器代码：**==\n\n```java\npackage com.Keafmd.controller;\n\nimport com.Keafmd.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.bind.support.SessionStatus;\n\nimport java.util.Date;\nimport java.util.Map;\n\n/**\n * Keafmd\n *\n * @ClassName: AnnoConteoller\n * @Description: 注解的控制器\n * @author: 牛哄哄的柯南\n * @date: 2021-01-25 10:50\n */\n@Controller\n@RequestMapping(\"/anno\")\npublic class AnnoConteoller {\n\n    /**\n     * requestParams 注解的使用\n     * @param username\n     * @return\n     */\n    @RequestMapping(\"/testRequestParam\")\n    public String testRequestParam(@RequestParam(value=\"name\") String username){\n        // @RequestParam(value=\"name\") 必须传name,required：请求参数中是否必须提供此参数，默认值是true，必须提供\n        // 获得当前类名\n        String clazz = Thread.currentThread().getStackTrace()[1].getClassName();\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n\n        System.out.println(\"执行了：\"+clazz+\" - \"+method);\n        System.out.println(\"username:\"+username);\n        return \"success\";\n    }\n\n}\n```\n==**输出结果：**==\n\n```java\n执行了：com.Keafmd.controller.AnnoConteoller - testRequestParam\nusername:keafmd\n```\n\n>**这样我们在href中传入name就会赋值给username。**\n\n# RequestBody\n<font size =5>**说明**</font>\n>**==作用：==\n>用于获取请求体内容。直接使用得到是 key=value&key=value...结构的数据。\n>get 请求方式不适用。\n>==属性：==\n>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<form action=\"anno/testRequestBody\" method=\"post\">\n        用户姓名：<input type=\"text\" name=\"uname\" /><br/>\n        用户年龄：<input type=\"text\" name=\"age\" /><br/>\n        用户生日：<input type=\"text\" name=\"birthday\" /><br/>\n        <input type=\"submit\" value=\"提交\">\n</form>\n```\n==**控制器代码：**==\n\n```java\n/**\n* 获取到请求体的内容 RequestBody\n */\n\n@RequestMapping(\"/testRequestBody\")\npublic String testRequestBody(@RequestBody String body){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(\"body:\"+body);\n    return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testRequestBody\nbody:uname=Keafmd&age=21&birthday=2000-01-01\n```\n# PathVaribale\n\n## 先了解下REST 风格 URL\n\n>**REST（英文：Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。**\n>![在这里插入图片描述](https://img-blog.csdnimg.cn/20210125191242816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4MzkxNw==,size_16,color_FFFFFF,t_70)\n\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。\n>url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。\n>==属性：==\n>value：用于指定 url 中占位符名称。\n>required：是否必须提供占位符。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testPathVariable/10\">testPathVariable</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n* PathVariable\n* @param id\n* @return\n*/\n@RequestMapping(\"/testPathVariable/{sid}\")\npublic String testPathVariable(@PathVariable(name=\"sid\") String id){\n   // 获得当前方法名\n   String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n   System.out.println(\"执行了：\"+\" \"+method);\n   System.out.println(\"id:\"+id);\n   return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testPathVariable\nid:10\n```\n# RequestHeader\n<font size =5>**说明**</font>\n>**==作用：==\n>用于获取请求消息头。\n>==属性：==\n>value：提供消息头名称\n>required：是否必须有此消息头\n>==提示：==\n>在实际开发中一般不常用**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testRequestHeader\">testRequestHeader</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n* RequestHeader获取请求头的值  不常用\n* @param head\n* @return\n*/\n@RequestMapping(\"/testRequestHeader\")\npublic String testRequestHeader(@RequestHeader(value = \"Accept\") String head){\n   // 获得当前方法名\n   String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n   System.out.println(\"执行了：\"+\" \"+method);\n\n   System.out.println(\"head:\"+head);\n   return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testRequestHeader\nhead:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\n```\n# CookieValue\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于把指定 cookie 名称的值传入控制器方法参数。\n>==属性：==\n>value：指定 cookie 的名称。\n>required：是否必须有此 cookie。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n\n```java\n<a href=\"anno/testCookieValue\">testCookValue</a><br/>\n```\n==**控制器代码：**==\n\n```java\n/**\n * CookieValue 不常用\n * @param cookievalue\n * @return\n */\n@RequestMapping(\"/testCookieValue\")\npublic String testCookieValue(@CookieValue(value = \"JSESSIONID\") String cookievalue){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n\n    System.out.println(\"cookievalue:\"+cookievalue);\n    return \"success\";\n}\n```\n\n==**输出结果：**==\n```java\n执行了： testCookieValue\ncookievalue:DCCFE2C1F975AC04D4F55973ADA5C89C\n```\n\n# ModelAttribute\n\n<font size =5>**说明**</font>\n>**==作用：==\n>该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。\n>出现在方法上，表示==当前方法会在控制器的方法执行之前，先执行==。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。\n>出现在参数上，获取指定的数据给参数赋值。\n>==属性：==\n>value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。\n>==应用场景：==\n>当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n```java\n<form action=\"anno/testModelAttribute\" method=\"post\">\n\t用户姓名：<input type=\"text\" name=\"uname\" /><br/>\n    用户年龄：<input type=\"text\" name=\"age\" /><br/>\n    <input type=\"submit\" value=\"提交\">\n</form>\n```\n## 修饰的方法有返回值\n==**控制器代码：**==\n\n```java\n/**\n * ModelAttribute\n * @return\n */\n\n@RequestMapping(\"/testModelAttribute\")\npublic String testModelAttribute(User user){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(user);\n    return \"success\";\n}\n\n//有返回值\n@ModelAttribute\npublic User showUser(String uname){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    User user = new User();\n    user.setUname(uname);\n    user.setAge(20);\n    user.setBirthday(new Date());\n    return user;\n}\n```\n==**输出结果：**==\n```java\n执行了： testModelAttribute\nUser{uname='牛哄哄的柯南', age=21, birthday=Mon Jan 25 19:34:46 CST 2021}\n```\n\n\n## 修饰的方法没有返回值\n>**==注意==：没有返回值的时候利用Map把参数传回去，testModelAttribute的参数User前加上@ModelAttribute(\"abc\")接收Map传回的数据。**\n\n==**控制器代码：**==\n\n```java\n/**\n * ModelAttribute\n * @return\n */\n\n@RequestMapping(\"/testModelAttribute\")\npublic String testModelAttribute(@ModelAttribute(\"abc\")User user){\n    // 获得当前方法名\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    System.out.println(user);\n    return \"success\";\n}\n\n//无返回值\n@ModelAttribute\npublic void showUser(String uname, Map<String,User> map){\n    String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n    System.out.println(\"执行了：\"+\" \"+method);\n    User user = new User();\n    user.setUname(uname);\n    user.setAge(20);\n    user.setBirthday(new Date());\n    map.put(\"abc\",user);\n}\n```\n\n\n==**输出结果：**==\n```java\n执行了： testModelAttribute\nUser{uname='牛哄哄的柯南', age=21, birthday=Mon Jan 25 19:32:20 CST 2021}\n```\n\n# SessionAttribute\n\n<font size =5>**说明**</font>\n>**==作用：==\n>用于多次执行控制器方法间的参数共享。\n>==属性：==\n>value：用于指定存入的属性名称\n>type：用于指定存入的数据类型。**\n\n<font size =5>**代码示例**</font>\n\n==**jsp代码：**==\n```java\n<a href=\"anno/testSessionAttributes\">存入SessionAttributes</a><br/>\n<a href=\"anno/getSessionAttributes\">获取SessionAttributes</a><br/>\n<a href=\"anno/delSessionAttributes\">清除SessionAttributes</a><br/>\n```\n==**控制器代码：**==\n>**注意：需要在类的上面添加`@SessionAttributes(value = {\"msg\"}) //把msg=牛哄哄的柯南存到session域中`。**\n\n```java\npackage com.Keafmd.controller;\n\nimport com.Keafmd.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.bind.support.SessionStatus;\n\nimport java.util.Date;\nimport java.util.Map;\n\n/**\n * Keafmd\n *\n * @ClassName: AnnoConteoller\n * @Description: 注解的控制器\n * @author: 牛哄哄的柯南\n * @date: 2021-01-25 10:50\n */\n@Controller\n@RequestMapping(\"/anno\")\n@SessionAttributes(value = {\"msg\"}) //把msg=牛哄哄的柯南存到session域中\npublic class AnnoConteoller {\n\n    /**\n     * SessionAttributes注解，存入msg\n     * @return\n     */\n    @RequestMapping(\"/testSessionAttributes\")\n    public String testSessionAttributes(Model model){\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //底层会存到Request域中\n        model.addAttribute(\"msg\",\"牛哄哄的柯南\");\n\n        return \"success\";\n    }\n\n    /**\n     * 获取\n     * @param modelMap\n     * @return\n     */\n    @RequestMapping(\"/getSessionAttributes\")\n    public String getSessionAttributes(ModelMap modelMap){\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //从session域中取出来\n        String msg = (String)modelMap.get(\"msg\");\n        System.out.println(msg);\n        return \"success\";\n    }\n\n    /**\n     * 清除\n     * @param sessionStatus\n     * @return\n     */\n    @RequestMapping(\"/delSessionAttributes\")\n    public String delSessionAttributes(SessionStatus sessionStatus) {\n        // 获得当前方法名\n        String method = Thread.currentThread().getStackTrace()[1].getMethodName();\n        System.out.println(\"执行了：\"+\" \"+method);\n\n        //从session域中清除\n        sessionStatus.setComplete();\n        return \"success\";\n    }\n\n\n}\n\n```\n>**依次点击存入->获取->清除->获取。**\n\n==**输出结果：**==\n```java\n执行了： testSessionAttributes\n执行了： getSessionAttributes\n牛哄哄的柯南\n执行了： delSessionAttributes\n执行了： getSessionAttributes\nnull\n```\n\n>**在success.jsp可以通过`${msg}和${sessionScope}`获取到在类上面把msg存入到session域的内容：`牛哄哄的柯南和{msg=牛哄哄的柯南}`**\n>**在success.jsp可以通过`${requestScope}`获取到在testSessionAttributes方法中存入Request域中的内容。**\n\n>**以上就是SpringMVC中常用注解（案例讲解）的全部内容。**","tags":["Keafmd"]},{"title":"Hello World","url":"/2021/01/25/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]